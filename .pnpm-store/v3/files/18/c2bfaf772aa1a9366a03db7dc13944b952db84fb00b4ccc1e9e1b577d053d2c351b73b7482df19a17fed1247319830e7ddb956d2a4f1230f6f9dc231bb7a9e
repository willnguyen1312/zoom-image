{"version":3,"sources":["container/TreeContainer/Base/index.js","../../src/container/TreeContainer/Base/index.ts"],"names":["__extends","this","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","TreeNode","TreeNodeEnableIndex","Container","throwIteratorAccessError","TreeContainer","_super","cmp","enableIndex","x","y","_this","_root","undefined","_cmp","_TreeNodeClass","_header","_lowerBound","curNode","key","resNode","cmpResult","_key","_right","_left","_upperBound","_reverseLowerBound","_reverseUpperBound","_eraseNodeSelfBalance","parentNode","_parent","_color","brother","_rotateLeft","_rotateRight","_eraseNode","_length","clear","swapNode","value","_value","_subTreeSize","_inOrderTraversal","param","pos","callback","nodeList","index","stack","length","push","pop","_insertNodeSelfBalance","grandParent","uncle","GP","_recount","_set","hint","minNode","compareToMin","maxNode","compareToMax","iterNode","_node","iterCmpRes","preNode","_pre","preCmpRes","parent_1","_getTreeNodeByKey","updateKeyByIterator","iter","node","nextKey","_next","preKey","eraseElementByPos","RangeError","eraseElementByKey","eraseElementByIterator","hasNoRight","isNormal","iteratorType","next","getHeight","traversal","Math","max"],"mappings":"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","file":"index.js","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { TreeNode, TreeNodeEnableIndex } from './TreeNode';\nimport { Container } from \"../../ContainerBase\";\nimport $checkWithinAccessParams from \"../../../utils/checkParams.macro\";\nimport { throwIteratorAccessError } from \"../../../utils/throwError\";\nvar TreeContainer = /** @class */ (function (_super) {\n    __extends(TreeContainer, _super);\n    /**\n     * @internal\n     */\n    function TreeContainer(cmp, enableIndex) {\n        if (cmp === void 0) { cmp = function (x, y) {\n            if (x < y)\n                return -1;\n            if (x > y)\n                return 1;\n            return 0;\n        }; }\n        if (enableIndex === void 0) { enableIndex = false; }\n        var _this = _super.call(this) || this;\n        /**\n         * @internal\n         */\n        _this._root = undefined;\n        _this._cmp = cmp;\n        _this.enableIndex = enableIndex;\n        _this._TreeNodeClass = enableIndex ? TreeNodeEnableIndex : TreeNode;\n        _this._header = new _this._TreeNodeClass();\n        return _this;\n    }\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._lowerBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                curNode = curNode._right;\n            }\n            else if (cmpResult > 0) {\n                resNode = curNode;\n                curNode = curNode._left;\n            }\n            else\n                return curNode;\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._upperBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult <= 0) {\n                curNode = curNode._right;\n            }\n            else {\n                resNode = curNode;\n                curNode = curNode._left;\n            }\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._reverseLowerBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                resNode = curNode;\n                curNode = curNode._right;\n            }\n            else if (cmpResult > 0) {\n                curNode = curNode._left;\n            }\n            else\n                return curNode;\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._reverseUpperBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                resNode = curNode;\n                curNode = curNode._right;\n            }\n            else {\n                curNode = curNode._left;\n            }\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._eraseNodeSelfBalance = function (curNode) {\n        while (true) {\n            var parentNode = curNode._parent;\n            if (parentNode === this._header)\n                return;\n            if (curNode._color === 1 /* TreeNodeColor.RED */) {\n                curNode._color = 0 /* TreeNodeColor.BLACK */;\n                return;\n            }\n            if (curNode === parentNode._left) {\n                var brother = parentNode._right;\n                if (brother._color === 1 /* TreeNodeColor.RED */) {\n                    brother._color = 0 /* TreeNodeColor.BLACK */;\n                    parentNode._color = 1 /* TreeNodeColor.RED */;\n                    if (parentNode === this._root) {\n                        this._root = parentNode._rotateLeft();\n                    }\n                    else\n                        parentNode._rotateLeft();\n                }\n                else {\n                    if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = parentNode._color;\n                        parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._right._color = 0 /* TreeNodeColor.BLACK */;\n                        if (parentNode === this._root) {\n                            this._root = parentNode._rotateLeft();\n                        }\n                        else\n                            parentNode._rotateLeft();\n                        return;\n                    }\n                    else if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        brother._left._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._rotateRight();\n                    }\n                    else {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        curNode = parentNode;\n                    }\n                }\n            }\n            else {\n                var brother = parentNode._left;\n                if (brother._color === 1 /* TreeNodeColor.RED */) {\n                    brother._color = 0 /* TreeNodeColor.BLACK */;\n                    parentNode._color = 1 /* TreeNodeColor.RED */;\n                    if (parentNode === this._root) {\n                        this._root = parentNode._rotateRight();\n                    }\n                    else\n                        parentNode._rotateRight();\n                }\n                else {\n                    if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = parentNode._color;\n                        parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._left._color = 0 /* TreeNodeColor.BLACK */;\n                        if (parentNode === this._root) {\n                            this._root = parentNode._rotateRight();\n                        }\n                        else\n                            parentNode._rotateRight();\n                        return;\n                    }\n                    else if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        brother._right._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._rotateLeft();\n                    }\n                    else {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        curNode = parentNode;\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._eraseNode = function (curNode) {\n        if (this._length === 1) {\n            this.clear();\n            return;\n        }\n        var swapNode = curNode;\n        while (swapNode._left || swapNode._right) {\n            if (swapNode._right) {\n                swapNode = swapNode._right;\n                while (swapNode._left)\n                    swapNode = swapNode._left;\n            }\n            else {\n                swapNode = swapNode._left;\n            }\n            var key = curNode._key;\n            curNode._key = swapNode._key;\n            swapNode._key = key;\n            var value = curNode._value;\n            curNode._value = swapNode._value;\n            swapNode._value = value;\n            curNode = swapNode;\n        }\n        if (this._header._left === swapNode) {\n            this._header._left = swapNode._parent;\n        }\n        else if (this._header._right === swapNode) {\n            this._header._right = swapNode._parent;\n        }\n        this._eraseNodeSelfBalance(swapNode);\n        var _parent = swapNode._parent;\n        if (swapNode === _parent._left) {\n            _parent._left = undefined;\n        }\n        else\n            _parent._right = undefined;\n        this._length -= 1;\n        this._root._color = 0 /* TreeNodeColor.BLACK */;\n        if (this.enableIndex) {\n            while (_parent !== this._header) {\n                _parent._subTreeSize -= 1;\n                _parent = _parent._parent;\n            }\n        }\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._inOrderTraversal = function (param) {\n        var pos = typeof param === 'number' ? param : undefined;\n        var callback = typeof param === 'function' ? param : undefined;\n        var nodeList = typeof param === 'undefined' ? [] : undefined;\n        var index = 0;\n        var curNode = this._root;\n        var stack = [];\n        while (stack.length || curNode) {\n            if (curNode) {\n                stack.push(curNode);\n                curNode = curNode._left;\n            }\n            else {\n                curNode = stack.pop();\n                if (index === pos)\n                    return curNode;\n                nodeList && nodeList.push(curNode);\n                callback && callback(curNode, index, this);\n                index += 1;\n                curNode = curNode._right;\n            }\n        }\n        return nodeList;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._insertNodeSelfBalance = function (curNode) {\n        while (true) {\n            var parentNode = curNode._parent;\n            if (parentNode._color === 0 /* TreeNodeColor.BLACK */)\n                return;\n            var grandParent = parentNode._parent;\n            if (parentNode === grandParent._left) {\n                var uncle = grandParent._right;\n                if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {\n                    uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root)\n                        return;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    curNode = grandParent;\n                    continue;\n                }\n                else if (curNode === parentNode._right) {\n                    curNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (curNode._left) {\n                        curNode._left._parent = parentNode;\n                    }\n                    if (curNode._right) {\n                        curNode._right._parent = grandParent;\n                    }\n                    parentNode._right = curNode._left;\n                    grandParent._left = curNode._right;\n                    curNode._left = parentNode;\n                    curNode._right = grandParent;\n                    if (grandParent === this._root) {\n                        this._root = curNode;\n                        this._header._parent = curNode;\n                    }\n                    else {\n                        var GP = grandParent._parent;\n                        if (GP._left === grandParent) {\n                            GP._left = curNode;\n                        }\n                        else\n                            GP._right = curNode;\n                    }\n                    curNode._parent = grandParent._parent;\n                    parentNode._parent = curNode;\n                    grandParent._parent = curNode;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                }\n                else {\n                    parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root) {\n                        this._root = grandParent._rotateRight();\n                    }\n                    else\n                        grandParent._rotateRight();\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    return;\n                }\n            }\n            else {\n                var uncle = grandParent._left;\n                if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {\n                    uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root)\n                        return;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    curNode = grandParent;\n                    continue;\n                }\n                else if (curNode === parentNode._left) {\n                    curNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (curNode._left) {\n                        curNode._left._parent = grandParent;\n                    }\n                    if (curNode._right) {\n                        curNode._right._parent = parentNode;\n                    }\n                    grandParent._right = curNode._left;\n                    parentNode._left = curNode._right;\n                    curNode._left = grandParent;\n                    curNode._right = parentNode;\n                    if (grandParent === this._root) {\n                        this._root = curNode;\n                        this._header._parent = curNode;\n                    }\n                    else {\n                        var GP = grandParent._parent;\n                        if (GP._left === grandParent) {\n                            GP._left = curNode;\n                        }\n                        else\n                            GP._right = curNode;\n                    }\n                    curNode._parent = grandParent._parent;\n                    parentNode._parent = curNode;\n                    grandParent._parent = curNode;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                }\n                else {\n                    parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root) {\n                        this._root = grandParent._rotateLeft();\n                    }\n                    else\n                        grandParent._rotateLeft();\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    return;\n                }\n            }\n            if (this.enableIndex) {\n                parentNode._recount();\n                grandParent._recount();\n                curNode._recount();\n            }\n            return;\n        }\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._set = function (key, value, hint) {\n        if (this._root === undefined) {\n            this._length += 1;\n            this._root = new this._TreeNodeClass(key, value, 0 /* TreeNodeColor.BLACK */);\n            this._root._parent = this._header;\n            this._header._parent = this._header._left = this._header._right = this._root;\n            return this._length;\n        }\n        var curNode;\n        var minNode = this._header._left;\n        var compareToMin = this._cmp(minNode._key, key);\n        if (compareToMin === 0) {\n            minNode._value = value;\n            return this._length;\n        }\n        else if (compareToMin > 0) {\n            minNode._left = new this._TreeNodeClass(key, value);\n            minNode._left._parent = minNode;\n            curNode = minNode._left;\n            this._header._left = curNode;\n        }\n        else {\n            var maxNode = this._header._right;\n            var compareToMax = this._cmp(maxNode._key, key);\n            if (compareToMax === 0) {\n                maxNode._value = value;\n                return this._length;\n            }\n            else if (compareToMax < 0) {\n                maxNode._right = new this._TreeNodeClass(key, value);\n                maxNode._right._parent = maxNode;\n                curNode = maxNode._right;\n                this._header._right = curNode;\n            }\n            else {\n                if (hint !== undefined) {\n                    var iterNode = hint._node;\n                    if (iterNode !== this._header) {\n                        var iterCmpRes = this._cmp(iterNode._key, key);\n                        if (iterCmpRes === 0) {\n                            iterNode._value = value;\n                            return this._length;\n                        }\n                        else /* istanbul ignore else */ if (iterCmpRes > 0) {\n                            var preNode = iterNode._pre();\n                            var preCmpRes = this._cmp(preNode._key, key);\n                            if (preCmpRes === 0) {\n                                preNode._value = value;\n                                return this._length;\n                            }\n                            else if (preCmpRes < 0) {\n                                curNode = new this._TreeNodeClass(key, value);\n                                if (preNode._right === undefined) {\n                                    preNode._right = curNode;\n                                    curNode._parent = preNode;\n                                }\n                                else {\n                                    iterNode._left = curNode;\n                                    curNode._parent = iterNode;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (curNode === undefined) {\n                    curNode = this._root;\n                    while (true) {\n                        var cmpResult = this._cmp(curNode._key, key);\n                        if (cmpResult > 0) {\n                            if (curNode._left === undefined) {\n                                curNode._left = new this._TreeNodeClass(key, value);\n                                curNode._left._parent = curNode;\n                                curNode = curNode._left;\n                                break;\n                            }\n                            curNode = curNode._left;\n                        }\n                        else if (cmpResult < 0) {\n                            if (curNode._right === undefined) {\n                                curNode._right = new this._TreeNodeClass(key, value);\n                                curNode._right._parent = curNode;\n                                curNode = curNode._right;\n                                break;\n                            }\n                            curNode = curNode._right;\n                        }\n                        else {\n                            curNode._value = value;\n                            return this._length;\n                        }\n                    }\n                }\n            }\n        }\n        if (this.enableIndex) {\n            var parent_1 = curNode._parent;\n            while (parent_1 !== this._header) {\n                parent_1._subTreeSize += 1;\n                parent_1 = parent_1._parent;\n            }\n        }\n        this._insertNodeSelfBalance(curNode);\n        this._length += 1;\n        return this._length;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._getTreeNodeByKey = function (curNode, key) {\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                curNode = curNode._right;\n            }\n            else if (cmpResult > 0) {\n                curNode = curNode._left;\n            }\n            else\n                return curNode;\n        }\n        return curNode || this._header;\n    };\n    TreeContainer.prototype.clear = function () {\n        this._length = 0;\n        this._root = undefined;\n        this._header._parent = undefined;\n        this._header._left = this._header._right = undefined;\n    };\n    /**\n     * @description Update node's key by iterator.\n     * @param iter - The iterator you want to change.\n     * @param key - The key you want to update.\n     * @returns Whether the modification is successful.\n     * @example\n     * const st = new orderedSet([1, 2, 5]);\n     * const iter = st.find(2);\n     * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]\n     */\n    TreeContainer.prototype.updateKeyByIterator = function (iter, key) {\n        var node = iter._node;\n        if (node === this._header) {\n            throwIteratorAccessError();\n        }\n        if (this._length === 1) {\n            node._key = key;\n            return true;\n        }\n        var nextKey = node._next()._key;\n        if (node === this._header._left) {\n            if (this._cmp(nextKey, key) > 0) {\n                node._key = key;\n                return true;\n            }\n            return false;\n        }\n        var preKey = node._pre()._key;\n        if (node === this._header._right) {\n            if (this._cmp(preKey, key) < 0) {\n                node._key = key;\n                return true;\n            }\n            return false;\n        }\n        if (this._cmp(preKey, key) >= 0 ||\n            this._cmp(nextKey, key) <= 0)\n            return false;\n        node._key = key;\n        return true;\n    };\n    TreeContainer.prototype.eraseElementByPos = function (pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        var node = this._inOrderTraversal(pos);\n        this._eraseNode(node);\n        return this._length;\n    };\n    /**\n     * @description Remove the element of the specified key.\n     * @param key - The key you want to remove.\n     * @returns Whether erase successfully.\n     */\n    TreeContainer.prototype.eraseElementByKey = function (key) {\n        if (this._length === 0)\n            return false;\n        var curNode = this._getTreeNodeByKey(this._root, key);\n        if (curNode === this._header)\n            return false;\n        this._eraseNode(curNode);\n        return true;\n    };\n    TreeContainer.prototype.eraseElementByIterator = function (iter) {\n        var node = iter._node;\n        if (node === this._header) {\n            throwIteratorAccessError();\n        }\n        var hasNoRight = node._right === undefined;\n        var isNormal = iter.iteratorType === 0 /* IteratorType.NORMAL */;\n        // For the normal iterator, the `next` node will be swapped to `this` node when has right.\n        if (isNormal) {\n            // So we should move it to next when it's right is null.\n            if (hasNoRight)\n                iter.next();\n        }\n        else {\n            // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.\n            // So when it has right, or it is a leaf node we should move it to `next`.\n            if (!hasNoRight || node._left === undefined)\n                iter.next();\n        }\n        this._eraseNode(node);\n        return iter;\n    };\n    /**\n     * @description Get the height of the tree.\n     * @returns Number about the height of the RB-tree.\n     */\n    TreeContainer.prototype.getHeight = function () {\n        if (this._length === 0)\n            return 0;\n        function traversal(curNode) {\n            if (!curNode)\n                return 0;\n            return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;\n        }\n        return traversal(this._root);\n    };\n    return TreeContainer;\n}(Container));\nexport default TreeContainer;\n","import type TreeIterator from './TreeIterator';\nimport { TreeNode, TreeNodeColor, TreeNodeEnableIndex } from './TreeNode';\nimport { Container, IteratorType } from '@/container/ContainerBase';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nabstract class TreeContainer<K, V> extends Container<K | [K, V]> {\n  enableIndex: boolean;\n  /**\n   * @internal\n   */\n  protected _header: TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected _root: TreeNode<K, V> | undefined = undefined;\n  /**\n   * @internal\n   */\n  protected readonly _cmp: (x: K, y: K) => number;\n  /**\n   * @internal\n   */\n  protected readonly _TreeNodeClass: typeof TreeNode | typeof TreeNodeEnableIndex;\n  /**\n   * @internal\n   */\n  protected constructor(\n    cmp: (x: K, y: K) => number =\n    function (x: K, y: K) {\n      if (x < y) return -1;\n      if (x > y) return 1;\n      return 0;\n    },\n    enableIndex = false\n  ) {\n    super();\n    this._cmp = cmp;\n    this.enableIndex = enableIndex;\n    this._TreeNodeClass = enableIndex ? TreeNodeEnableIndex : TreeNode;\n    this._header = new this._TreeNodeClass();\n  }\n  /**\n   * @internal\n   */\n  protected _lowerBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        resNode = curNode;\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _upperBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult <= 0) {\n        curNode = curNode._right;\n      } else {\n        resNode = curNode;\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _reverseLowerBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _reverseUpperBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else {\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _eraseNodeSelfBalance(curNode: TreeNode<K, V>) {\n    while (true) {\n      const parentNode = curNode._parent!;\n      if (parentNode === this._header) return;\n      if (curNode._color === TreeNodeColor.RED) {\n        curNode._color = TreeNodeColor.BLACK;\n        return;\n      }\n      if (curNode === parentNode._left) {\n        const brother = parentNode._right!;\n        if (brother._color === TreeNodeColor.RED) {\n          brother._color = TreeNodeColor.BLACK;\n          parentNode._color = TreeNodeColor.RED;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateLeft();\n          } else parentNode._rotateLeft();\n        } else {\n          if (brother._right && brother._right._color === TreeNodeColor.RED) {\n            brother._color = parentNode._color;\n            parentNode._color = TreeNodeColor.BLACK;\n            brother._right._color = TreeNodeColor.BLACK;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateLeft();\n            } else parentNode._rotateLeft();\n            return;\n          } else if (brother._left && brother._left._color === TreeNodeColor.RED) {\n            brother._color = TreeNodeColor.RED;\n            brother._left._color = TreeNodeColor.BLACK;\n            brother._rotateRight();\n          } else {\n            brother._color = TreeNodeColor.RED;\n            curNode = parentNode;\n          }\n        }\n      } else {\n        const brother = parentNode._left!;\n        if (brother._color === TreeNodeColor.RED) {\n          brother._color = TreeNodeColor.BLACK;\n          parentNode._color = TreeNodeColor.RED;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateRight();\n          } else parentNode._rotateRight();\n        } else {\n          if (brother._left && brother._left._color === TreeNodeColor.RED) {\n            brother._color = parentNode._color;\n            parentNode._color = TreeNodeColor.BLACK;\n            brother._left._color = TreeNodeColor.BLACK;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateRight();\n            } else parentNode._rotateRight();\n            return;\n          } else if (brother._right && brother._right._color === TreeNodeColor.RED) {\n            brother._color = TreeNodeColor.RED;\n            brother._right._color = TreeNodeColor.BLACK;\n            brother._rotateLeft();\n          } else {\n            brother._color = TreeNodeColor.RED;\n            curNode = parentNode;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  protected _eraseNode(curNode: TreeNode<K, V>) {\n    if (this._length === 1) {\n      this.clear();\n      return;\n    }\n    let swapNode = curNode;\n    while (swapNode._left || swapNode._right) {\n      if (swapNode._right) {\n        swapNode = swapNode._right;\n        while (swapNode._left) swapNode = swapNode._left;\n      } else {\n        swapNode = swapNode._left!;\n      }\n      const key = curNode._key;\n      curNode._key = swapNode._key;\n      swapNode._key = key;\n      const value = curNode._value;\n      curNode._value = swapNode._value;\n      swapNode._value = value;\n      curNode = swapNode;\n    }\n    if (this._header._left === swapNode) {\n      this._header._left = swapNode._parent;\n    } else if (this._header._right === swapNode) {\n      this._header._right = swapNode._parent;\n    }\n    this._eraseNodeSelfBalance(swapNode);\n    let _parent = swapNode._parent as TreeNodeEnableIndex<K, V>;\n    if (swapNode === _parent._left) {\n      _parent._left = undefined;\n    } else _parent._right = undefined;\n    this._length -= 1;\n    this._root!._color = TreeNodeColor.BLACK;\n    if (this.enableIndex) {\n      while (_parent !== this._header) {\n        _parent._subTreeSize -= 1;\n        _parent = _parent._parent as TreeNodeEnableIndex<K, V>;\n      }\n    }\n  }\n  protected _inOrderTraversal(): TreeNode<K, V>[];\n  protected _inOrderTraversal(pos: number): TreeNode<K, V>;\n  protected _inOrderTraversal(\n    callback: (node: TreeNode<K, V>, index: number, map: this) => void\n  ): TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected _inOrderTraversal(\n    param?: number | ((node: TreeNode<K, V>, index: number, map: this) => void)\n  ) {\n    const pos = typeof param === 'number' ? param : undefined;\n    const callback = typeof param === 'function' ? param : undefined;\n    const nodeList = typeof param === 'undefined' ? <TreeNode<K, V>[]>[] : undefined;\n    let index = 0;\n    let curNode = this._root;\n    const stack: TreeNode<K, V>[] = [];\n    while (stack.length || curNode) {\n      if (curNode) {\n        stack.push(curNode);\n        curNode = curNode._left;\n      } else {\n        curNode = stack.pop()!;\n        if (index === pos) return curNode;\n        nodeList && nodeList.push(curNode);\n        callback && callback(curNode, index, this);\n        index += 1;\n        curNode = curNode._right;\n      }\n    }\n    return nodeList;\n  }\n  /**\n   * @internal\n   */\n  protected _insertNodeSelfBalance(curNode: TreeNode<K, V>) {\n    while (true) {\n      const parentNode = curNode._parent!;\n      if (parentNode._color === TreeNodeColor.BLACK) return;\n      const grandParent = parentNode._parent!;\n      if (parentNode === grandParent._left) {\n        const uncle = grandParent._right;\n        if (uncle && uncle._color === TreeNodeColor.RED) {\n          uncle._color = parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) return;\n          grandParent._color = TreeNodeColor.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._right) {\n          curNode._color = TreeNodeColor.BLACK;\n          if (curNode._left) {\n            curNode._left._parent = parentNode;\n          }\n          if (curNode._right) {\n            curNode._right._parent = grandParent;\n          }\n          parentNode._right = curNode._left;\n          grandParent._left = curNode._right;\n          curNode._left = parentNode;\n          curNode._right = grandParent;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent!;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = TreeNodeColor.RED;\n        } else {\n          parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateRight();\n          } else grandParent._rotateRight();\n          grandParent._color = TreeNodeColor.RED;\n          return;\n        }\n      } else {\n        const uncle = grandParent._left;\n        if (uncle && uncle._color === TreeNodeColor.RED) {\n          uncle._color = parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) return;\n          grandParent._color = TreeNodeColor.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._left) {\n          curNode._color = TreeNodeColor.BLACK;\n          if (curNode._left) {\n            curNode._left._parent = grandParent;\n          }\n          if (curNode._right) {\n            curNode._right._parent = parentNode;\n          }\n          grandParent._right = curNode._left;\n          parentNode._left = curNode._right;\n          curNode._left = grandParent;\n          curNode._right = parentNode;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent!;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = TreeNodeColor.RED;\n        } else {\n          parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateLeft();\n          } else grandParent._rotateLeft();\n          grandParent._color = TreeNodeColor.RED;\n          return;\n        }\n      }\n      if (this.enableIndex) {\n        (<TreeNodeEnableIndex<K, V>>parentNode)._recount();\n        (<TreeNodeEnableIndex<K, V>>grandParent)._recount();\n        (<TreeNodeEnableIndex<K, V>>curNode)._recount();\n      }\n      return;\n    }\n  }\n  /**\n   * @internal\n   */\n  protected _set(key: K, value?: V, hint?: TreeIterator<K, V>) {\n    if (this._root === undefined) {\n      this._length += 1;\n      this._root = new this._TreeNodeClass(key, value, TreeNodeColor.BLACK);\n      this._root._parent = this._header;\n      this._header._parent = this._header._left = this._header._right = this._root;\n      return this._length;\n    }\n    let curNode;\n    const minNode = this._header._left!;\n    const compareToMin = this._cmp(minNode._key!, key);\n    if (compareToMin === 0) {\n      minNode._value = value;\n      return this._length;\n    } else if (compareToMin > 0) {\n      minNode._left = new this._TreeNodeClass(key, value);\n      minNode._left._parent = minNode;\n      curNode = minNode._left;\n      this._header._left = curNode;\n    } else {\n      const maxNode = this._header._right!;\n      const compareToMax = this._cmp(maxNode._key!, key);\n      if (compareToMax === 0) {\n        maxNode._value = value;\n        return this._length;\n      } else if (compareToMax < 0) {\n        maxNode._right = new this._TreeNodeClass(key, value);\n        maxNode._right._parent = maxNode;\n        curNode = maxNode._right;\n        this._header._right = curNode;\n      } else {\n        if (hint !== undefined) {\n          const iterNode = hint._node;\n          if (iterNode !== this._header) {\n            const iterCmpRes = this._cmp(iterNode._key!, key);\n            if (iterCmpRes === 0) {\n              iterNode._value = value;\n              return this._length;\n            } else /* istanbul ignore else */ if (iterCmpRes > 0) {\n              const preNode = iterNode._pre();\n              const preCmpRes = this._cmp(preNode._key!, key);\n              if (preCmpRes === 0) {\n                preNode._value = value;\n                return this._length;\n              } else if (preCmpRes < 0) {\n                curNode = new this._TreeNodeClass(key, value);\n                if (preNode._right === undefined) {\n                  preNode._right = curNode;\n                  curNode._parent = preNode;\n                } else {\n                  iterNode._left = curNode;\n                  curNode._parent = iterNode;\n                }\n              }\n            }\n          }\n        }\n        if (curNode === undefined) {\n          curNode = this._root;\n          while (true) {\n            const cmpResult = this._cmp(curNode._key!, key);\n            if (cmpResult > 0) {\n              if (curNode._left === undefined) {\n                curNode._left = new this._TreeNodeClass(key, value);\n                curNode._left._parent = curNode;\n                curNode = curNode._left;\n                break;\n              }\n              curNode = curNode._left;\n            } else if (cmpResult < 0) {\n              if (curNode._right === undefined) {\n                curNode._right = new this._TreeNodeClass(key, value);\n                curNode._right._parent = curNode;\n                curNode = curNode._right;\n                break;\n              }\n              curNode = curNode._right;\n            } else {\n              curNode._value = value;\n              return this._length;\n            }\n          }\n        }\n      }\n    }\n    if (this.enableIndex) {\n      let parent = curNode._parent as TreeNodeEnableIndex<K, V>;\n      while (parent !== this._header) {\n        parent._subTreeSize += 1;\n        parent = parent._parent as TreeNodeEnableIndex<K, V>;\n      }\n    }\n    this._insertNodeSelfBalance(curNode);\n    this._length += 1;\n    return this._length;\n  }\n  /**\n   * @internal\n   */\n  protected _getTreeNodeByKey(curNode: TreeNode<K, V> | undefined, key: K) {\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return curNode || this._header;\n  }\n  clear() {\n    this._length = 0;\n    this._root = undefined;\n    this._header._parent = undefined;\n    this._header._left = this._header._right = undefined;\n  }\n  /**\n   * @description Update node's key by iterator.\n   * @param iter - The iterator you want to change.\n   * @param key - The key you want to update.\n   * @returns Whether the modification is successful.\n   * @example\n   * const st = new orderedSet([1, 2, 5]);\n   * const iter = st.find(2);\n   * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]\n   */\n  updateKeyByIterator(iter: TreeIterator<K, V>, key: K): boolean {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    if (this._length === 1) {\n      node._key = key;\n      return true;\n    }\n    const nextKey = node._next()._key!;\n    if (node === this._header._left) {\n      if (this._cmp(nextKey, key) > 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    const preKey = node._pre()._key!;\n    if (node === this._header._right) {\n      if (this._cmp(preKey, key) < 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    if (\n      this._cmp(preKey, key) >= 0 ||\n      this._cmp(nextKey, key) <= 0\n    ) return false;\n    node._key = key;\n    return true;\n  }\n  eraseElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    const node = this._inOrderTraversal(pos);\n    this._eraseNode(node);\n    return this._length;\n  }\n  /**\n   * @description Remove the element of the specified key.\n   * @param key - The key you want to remove.\n   * @returns Whether erase successfully.\n   */\n  eraseElementByKey(key: K) {\n    if (this._length === 0) return false;\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    if (curNode === this._header) return false;\n    this._eraseNode(curNode);\n    return true;\n  }\n  eraseElementByIterator(iter: TreeIterator<K, V>) {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    const hasNoRight = node._right === undefined;\n    const isNormal = iter.iteratorType === IteratorType.NORMAL;\n    // For the normal iterator, the `next` node will be swapped to `this` node when has right.\n    if (isNormal) {\n      // So we should move it to next when it's right is null.\n      if (hasNoRight) iter.next();\n    } else {\n      // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.\n      // So when it has right, or it is a leaf node we should move it to `next`.\n      if (!hasNoRight || node._left === undefined) iter.next();\n    }\n    this._eraseNode(node);\n    return iter;\n  }\n  /**\n   * @description Get the height of the tree.\n   * @returns Number about the height of the RB-tree.\n   */\n  getHeight() {\n    if (this._length === 0) return 0;\n    function traversal(curNode: TreeNode<K, V> | undefined): number {\n      if (!curNode) return 0;\n      return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;\n    }\n    return traversal(this._root);\n  }\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element less than the given key.\n   */\n  abstract reverseUpperBound(key: K): TreeIterator<K, V>;\n  /**\n   * @description Union the other tree to self.\n   * @param other - The other tree container you want to merge.\n   * @returns The size of the tree after union.\n   */\n  abstract union(other: TreeContainer<K, V>): number;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element not greater than the given key.\n   */\n  abstract reverseLowerBound(key: K): TreeIterator<K, V>;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element not less than the given key.\n   */\n  abstract lowerBound(key: K): TreeIterator<K, V>;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element greater than the given key.\n   */\n  abstract upperBound(key: K): TreeIterator<K, V>;\n}\n\nexport default TreeContainer;\n"]}