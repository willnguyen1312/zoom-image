{"version":3,"sources":["container/TreeContainer/OrderedSet.js","../../src/container/TreeContainer/OrderedSet.ts"],"names":["Object","defineProperty","exports","value","default","_Base","_interopRequireDefault","require","_TreeIterator","_throwError","obj","__esModule","OrderedSetIterator","TreeIterator","constructor","node","header","container","iteratorType","super","this","pointer","_node","_header","throwIteratorAccessError","_key","copy","OrderedSet","TreeContainer","cmp","enableIndex","self","forEach","el","insert","begin","_left","end","rBegin","_right","rEnd","front","undefined","back","lowerBound","key","resNode","_lowerBound","_root","upperBound","_upperBound","reverseLowerBound","_reverseLowerBound","reverseUpperBound","_reverseUpperBound","callback","_inOrderTraversal","index","set","hint","_set","getElementByPos","pos","_length","RangeError","find","element","_getTreeNodeByKey","union","other","Symbol","iterator","length","nodeList","i","_default"],"mappings":"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","file":"OrderedSet.js","sourcesContent":["import TreeContainer from './Base';\nimport TreeIterator from './Base/TreeIterator';\nimport $checkWithinAccessParams from \"../../utils/checkParams.macro\";\nimport { throwIteratorAccessError } from \"../../utils/throwError\";\nclass OrderedSetIterator extends TreeIterator {\n    constructor(node, header, container, iteratorType) {\n        super(node, header, iteratorType);\n        this.container = container;\n    }\n    get pointer() {\n        if (this._node === this._header) {\n            throwIteratorAccessError();\n        }\n        return this._node._key;\n    }\n    copy() {\n        return new OrderedSetIterator(this._node, this._header, this.container, this.iteratorType);\n    }\n}\nclass OrderedSet extends TreeContainer {\n    /**\n     * @param container - The initialization container.\n     * @param cmp - The compare function.\n     * @param enableIndex - Whether to enable iterator indexing function.\n     * @example\n     * new OrderedSet();\n     * new OrderedSet([0, 1, 2]);\n     * new OrderedSet([0, 1, 2], (x, y) => x - y);\n     * new OrderedSet([0, 1, 2], (x, y) => x - y, true);\n     */\n    constructor(container = [], cmp, enableIndex) {\n        super(cmp, enableIndex);\n        const self = this;\n        container.forEach(function (el) {\n            self.insert(el);\n        });\n    }\n    begin() {\n        return new OrderedSetIterator(this._header._left || this._header, this._header, this);\n    }\n    end() {\n        return new OrderedSetIterator(this._header, this._header, this);\n    }\n    rBegin() {\n        return new OrderedSetIterator(this._header._right || this._header, this._header, this, 1 /* IteratorType.REVERSE */);\n    }\n    rEnd() {\n        return new OrderedSetIterator(this._header, this._header, this, 1 /* IteratorType.REVERSE */);\n    }\n    front() {\n        return this._header._left ? this._header._left._key : undefined;\n    }\n    back() {\n        return this._header._right ? this._header._right._key : undefined;\n    }\n    lowerBound(key) {\n        const resNode = this._lowerBound(this._root, key);\n        return new OrderedSetIterator(resNode, this._header, this);\n    }\n    upperBound(key) {\n        const resNode = this._upperBound(this._root, key);\n        return new OrderedSetIterator(resNode, this._header, this);\n    }\n    reverseLowerBound(key) {\n        const resNode = this._reverseLowerBound(this._root, key);\n        return new OrderedSetIterator(resNode, this._header, this);\n    }\n    reverseUpperBound(key) {\n        const resNode = this._reverseUpperBound(this._root, key);\n        return new OrderedSetIterator(resNode, this._header, this);\n    }\n    forEach(callback) {\n        this._inOrderTraversal(function (node, index, set) {\n            callback(node._key, index, set);\n        });\n    }\n    /**\n     * @description Insert element to set.\n     * @param key - The key want to insert.\n     * @param hint - You can give an iterator hint to improve insertion efficiency.\n     * @return The size of container after setting.\n     * @example\n     * const st = new OrderedSet([2, 4, 5]);\n     * const iter = st.begin();\n     * st.insert(1);\n     * st.insert(3, iter);  // give a hint will be faster.\n     */\n    insert(key, hint) {\n        return this._set(key, undefined, hint);\n    }\n    getElementByPos(pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        const node = this._inOrderTraversal(pos);\n        return node._key;\n    }\n    find(element) {\n        const resNode = this._getTreeNodeByKey(this._root, element);\n        return new OrderedSetIterator(resNode, this._header, this);\n    }\n    union(other) {\n        const self = this;\n        other.forEach(function (el) {\n            self.insert(el);\n        });\n        return this._length;\n    }\n    *[Symbol.iterator]() {\n        const length = this._length;\n        const nodeList = this._inOrderTraversal();\n        for (let i = 0; i < length; ++i) {\n            yield nodeList[i]._key;\n        }\n    }\n}\nexport default OrderedSet;\n","import TreeContainer from './Base';\nimport TreeIterator from './Base/TreeIterator';\nimport { TreeNode } from './Base/TreeNode';\nimport { initContainer, IteratorType } from '@/container/ContainerBase';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nclass OrderedSetIterator<K> extends TreeIterator<K, undefined> {\n  container: OrderedSet<K>;\n  constructor(\n    node: TreeNode<K, undefined>,\n    header: TreeNode<K, undefined>,\n    container: OrderedSet<K>,\n    iteratorType?: IteratorType\n  ) {\n    super(node, header, iteratorType);\n    this.container = container;\n  }\n  get pointer() {\n    if (this._node === this._header) {\n      throwIteratorAccessError();\n    }\n    return this._node._key!;\n  }\n  copy() {\n    return new OrderedSetIterator<K>(\n      this._node,\n      this._header,\n      this.container,\n      this.iteratorType\n    );\n  }\n  // @ts-ignore\n  equals(iter: OrderedSetIterator<K>): boolean;\n}\n\nexport type { OrderedSetIterator };\n\nclass OrderedSet<K> extends TreeContainer<K, undefined> {\n  /**\n   * @param container - The initialization container.\n   * @param cmp - The compare function.\n   * @param enableIndex - Whether to enable iterator indexing function.\n   * @example\n   * new OrderedSet();\n   * new OrderedSet([0, 1, 2]);\n   * new OrderedSet([0, 1, 2], (x, y) => x - y);\n   * new OrderedSet([0, 1, 2], (x, y) => x - y, true);\n   */\n  constructor(\n    container: initContainer<K> = [],\n    cmp?: (x: K, y: K) => number,\n    enableIndex?: boolean\n  ) {\n    super(cmp, enableIndex);\n    const self = this;\n    container.forEach(function (el) {\n      self.insert(el);\n    });\n  }\n  begin() {\n    return new OrderedSetIterator<K>(\n      this._header._left || this._header,\n      this._header,\n      this\n    );\n  }\n  end() {\n    return new OrderedSetIterator<K>(this._header, this._header, this);\n  }\n  rBegin() {\n    return new OrderedSetIterator<K>(\n      this._header._right || this._header,\n      this._header,\n      this,\n      IteratorType.REVERSE\n    );\n  }\n  rEnd() {\n    return new OrderedSetIterator<K>(this._header, this._header, this, IteratorType.REVERSE);\n  }\n  front() {\n    return this._header._left ? this._header._left._key : undefined;\n  }\n  back() {\n    return this._header._right ? this._header._right._key : undefined;\n  }\n  lowerBound(key: K) {\n    const resNode = this._lowerBound(this._root, key);\n    return new OrderedSetIterator<K>(resNode, this._header, this);\n  }\n  upperBound(key: K) {\n    const resNode = this._upperBound(this._root, key);\n    return new OrderedSetIterator<K>(resNode, this._header, this);\n  }\n  reverseLowerBound(key: K) {\n    const resNode = this._reverseLowerBound(this._root, key);\n    return new OrderedSetIterator<K>(resNode, this._header, this);\n  }\n  reverseUpperBound(key: K) {\n    const resNode = this._reverseUpperBound(this._root, key);\n    return new OrderedSetIterator<K>(resNode, this._header, this);\n  }\n  forEach(callback: (element: K, index: number, set: OrderedSet<K>) => void) {\n    this._inOrderTraversal(function (node, index, set) {\n      callback(node._key as K, index, set);\n    });\n  }\n  /**\n   * @description Insert element to set.\n   * @param key - The key want to insert.\n   * @param hint - You can give an iterator hint to improve insertion efficiency.\n   * @return The size of container after setting.\n   * @example\n   * const st = new OrderedSet([2, 4, 5]);\n   * const iter = st.begin();\n   * st.insert(1);\n   * st.insert(3, iter);  // give a hint will be faster.\n   */\n  insert(key: K, hint?: OrderedSetIterator<K>) {\n    return this._set(key, undefined, hint);\n  }\n  getElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    const node = this._inOrderTraversal(pos);\n    return node._key as K;\n  }\n  find(element: K) {\n    const resNode = this._getTreeNodeByKey(this._root, element);\n    return new OrderedSetIterator<K>(resNode, this._header, this);\n  }\n  union(other: OrderedSet<K>) {\n    const self = this;\n    other.forEach(function (el) {\n      self.insert(el);\n    });\n    return this._length;\n  }\n  * [Symbol.iterator]() {\n    const length = this._length;\n    const nodeList = this._inOrderTraversal();\n    for (let i = 0; i < length; ++i) {\n      yield nodeList[i]._key as K;\n    }\n  }\n  // @ts-ignore\n  eraseElementByIterator(iter: OrderedSetIterator<K>): OrderedSetIterator<K>;\n}\n\nexport default OrderedSet;\n"]}