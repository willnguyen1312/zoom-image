{"version":3,"sources":["container/TreeContainer/OrderedMap.js","../../src/container/TreeContainer/OrderedMap.ts"],"names":["Object","defineProperty","exports","value","default","_Base","_interopRequireDefault","require","_TreeIterator","_throwError","obj","__esModule","OrderedMapIterator","TreeIterator","constructor","node","header","container","iteratorType","super","this","pointer","_node","_header","throwIteratorAccessError","self","Proxy","get","_","props","_key","_value","set","newValue","TypeError","copy","OrderedMap","TreeContainer","cmp","enableIndex","forEach","el","setElement","begin","_left","end","rBegin","_right","rEnd","front","_length","minNode","back","maxNode","lowerBound","key","resNode","_lowerBound","_root","upperBound","_upperBound","reverseLowerBound","_reverseLowerBound","reverseUpperBound","_reverseUpperBound","callback","_inOrderTraversal","index","map","hint","_set","getElementByPos","pos","RangeError","find","curNode","_getTreeNodeByKey","getElementByKey","union","other","Symbol","iterator","length","nodeList","i","_default"],"mappings":"AAAA;;AAEAA,OAAOC,eAAeC,SAAS,KAAc;IAC3CC,OAAO;;;AAETD,QAAQE,eAAe;;ACLvB,IAAAC,QAAAC,uBAAAC,QAAA;;AACA,IAAAC,gBAAAF,uBAAAC,QAAA;;AAIA,IAAAE,cAAAF,QAAA;;AAA8D,SAAAD,uBAAAI;IAAA,OAAAA,KAAAA,EAAAC,IAAAD,IAAA;QAAAN,SAAAM;;AAAA;;AAE9D,MAAME,2BAAiCC,cAAAA;IAErCC,YACEC,GACAC,GACAC,GACAC;QAEAC,MAAMJ,GAAMC,GAAQE;QACpBE,KAAKH,YAAYA;ADRjB;ICUEI;QACF,IAAID,KAAKE,MAAUF,KAAKG,GAAS;aAC/B,GAAAC,YAAAA;ADRE;QCUJ,MAAMC,IAAOL;QACb,OAAO,IAAIM,MAAuB,IAAI;YACpCC,IAAIC,GAAGC;gBACL,IAAIA,MAAU,KAAK,OAAOJ,EAAKH,EAAMQ,QAChC,IAAID,MAAU,KAAK,OAAOJ,EAAKH,EAAMS;ADNtC;YCQNC,IAAIJ,GAAGC,GAAYI;gBACjB,IAAIJ,MAAU,KAAK;oBACjB,MAAM,IAAIK,UAAU;ADNd;gBCQRT,EAAKH,EAAMS,IAASE;gBACpB,OAAO;ADNH;;AAER;ICQFE;QACE,OAAO,IAAIvB,mBACTQ,KAAKE,GACLF,KAAKG,GACLH,KAAKH,WACLG,KAAKF;ADVP;;;ACmBJ,MAAMkB,mBAAyBC,MAAAA;IAW7BvB,YACEG,IAAmC,IACnCqB,GACAC;QAEApB,MAAMmB,GAAKC;QACX,MAAMd,IAAOL;QACbH,EAAUuB,SAAQ,SAAUC;YAC1BhB,EAAKiB,WAAWD,EAAG,IAAIA,EAAG;ADpBxB;AACJ;ICsBFE;QACE,OAAO,IAAI/B,mBAAyBQ,KAAKG,EAAQqB,KAASxB,KAAKG,GAASH,KAAKG,GAASH;ADpBtF;ICsBFyB;QACE,OAAO,IAAIjC,mBAAyBQ,KAAKG,GAASH,KAAKG,GAASH;ADpBhE;ICsBF0B;QACE,OAAO,IAAIlC,mBACTQ,KAAKG,EAAQwB,KAAU3B,KAAKG,GAC5BH,KAAKG,GACLH,MAAI;ADvBN;IC2BF4B;QACE,OAAO,IAAIpC,mBAAyBQ,KAAKG,GAASH,KAAKG,GAASH,MAAI;ADzBpE;IC2BF6B;QACE,IAAI7B,KAAK8B,MAAY,GAAG;QACxB,MAAMC,IAAU/B,KAAKG,EAAQqB;QAC7B,OAAe,EAACO,EAAQrB,GAAMqB,EAAQpB;ADxBtC;IC0BFqB;QACE,IAAIhC,KAAK8B,MAAY,GAAG;QACxB,MAAMG,IAAUjC,KAAKG,EAAQwB;QAC7B,OAAe,EAACM,EAAQvB,GAAMuB,EAAQtB;ADvBtC;ICyBFuB,WAAWC;QACT,MAAMC,IAAUpC,KAAKqC,EAAYrC,KAAKsC,GAAOH;QAC7C,OAAO,IAAI3C,mBAAyB4C,GAASpC,KAAKG,GAASH;ADvB3D;ICyBFuC,WAAWJ;QACT,MAAMC,IAAUpC,KAAKwC,EAAYxC,KAAKsC,GAAOH;QAC7C,OAAO,IAAI3C,mBAAyB4C,GAASpC,KAAKG,GAASH;ADvB3D;ICyBFyC,kBAAkBN;QAChB,MAAMC,IAAUpC,KAAK0C,EAAmB1C,KAAKsC,GAAOH;QACpD,OAAO,IAAI3C,mBAAyB4C,GAASpC,KAAKG,GAASH;ADvB3D;ICyBF2C,kBAAkBR;QAChB,MAAMC,IAAUpC,KAAK4C,EAAmB5C,KAAKsC,GAAOH;QACpD,OAAO,IAAI3C,mBAAyB4C,GAASpC,KAAKG,GAASH;ADvB3D;ICyBFoB,QAAQyB;QACN7C,KAAK8C,IAAkB,SAAUnD,GAAMoD,GAAOC;YAC5CH,EAAiB,EAAClD,EAAKe,GAAMf,EAAKgB,KAASoC,GAAOC;ADvBhD;AACJ;ICqCF1B,WAAWa,GAAQpD,GAAUkE;QAC3B,OAAOjD,KAAKkD,EAAKf,GAAKpD,GAAOkE;ADvB7B;ICyBFE,gBAAgBC;QDvBV,ICwBsBA,IAAG,KAAHA,IAAQpD,KAAK8B,IAAO,GAlItB;YAAC,MAAU,IAAIuB;AD4GnC;QCuBJ,MAAM1D,IAAOK,KAAK8C,GAAkBM;QACpC,OAAe,EAACzD,EAAKe,GAAMf,EAAKgB;ADrBhC;ICuBF2C,KAAKnB;QACH,MAAMoB,IAAUvD,KAAKwD,GAAkBxD,KAAKsC,GAAOH;QACnD,OAAO,IAAI3C,mBAAyB+D,GAASvD,KAAKG,GAASH;ADrB3D;IC6BFyD,gBAAgBtB;QACd,MAAMoB,IAAUvD,KAAKwD,GAAkBxD,KAAKsC,GAAOH;QACnD,OAAOoB,EAAQ5C;ADrBf;ICuBF+C,MAAMC;QACJ,MAAMtD,IAAOL;QACb2D,EAAMvC,SAAQ,SAAUC;YACtBhB,EAAKiB,WAAWD,EAAG,IAAIA,EAAG;ADrBxB;QCuBJ,OAAOrB,KAAK8B;ADrBZ;ICuBF,GAAG8B,OAAOC;QACR,MAAMC,IAAS9D,KAAK8B;QACpB,MAAMiC,IAAW/D,KAAK8C;QACtB,KAAK,IAAIkB,IAAI,GAAGA,IAAIF,KAAUE,GAAG;YAC/B,MAAMrE,IAAOoE,EAASC;kBACR,EAACrE,EAAKe,GAAMf,EAAKgB;ADrB7B;AACJ;;;ACyBH,IAAAsD,WAEcjD;;AAAUlC,QAAAE,UAAAiF","file":"OrderedMap.js","sourcesContent":["import TreeContainer from './Base';\nimport TreeIterator from './Base/TreeIterator';\nimport $checkWithinAccessParams from \"../../utils/checkParams.macro\";\nimport { throwIteratorAccessError } from \"../../utils/throwError\";\nclass OrderedMapIterator extends TreeIterator {\n    constructor(node, header, container, iteratorType) {\n        super(node, header, iteratorType);\n        this.container = container;\n    }\n    get pointer() {\n        if (this._node === this._header) {\n            throwIteratorAccessError();\n        }\n        const self = this;\n        return new Proxy([], {\n            get(_, props) {\n                if (props === '0')\n                    return self._node._key;\n                else if (props === '1')\n                    return self._node._value;\n            },\n            set(_, props, newValue) {\n                if (props !== '1') {\n                    throw new TypeError('props must be 1');\n                }\n                self._node._value = newValue;\n                return true;\n            }\n        });\n    }\n    copy() {\n        return new OrderedMapIterator(this._node, this._header, this.container, this.iteratorType);\n    }\n}\nclass OrderedMap extends TreeContainer {\n    /**\n     * @param container - The initialization container.\n     * @param cmp - The compare function.\n     * @param enableIndex - Whether to enable iterator indexing function.\n     * @example\n     * new OrderedMap();\n     * new OrderedMap([[0, 1], [2, 1]]);\n     * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y);\n     * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y, true);\n     */\n    constructor(container = [], cmp, enableIndex) {\n        super(cmp, enableIndex);\n        const self = this;\n        container.forEach(function (el) {\n            self.setElement(el[0], el[1]);\n        });\n    }\n    begin() {\n        return new OrderedMapIterator(this._header._left || this._header, this._header, this);\n    }\n    end() {\n        return new OrderedMapIterator(this._header, this._header, this);\n    }\n    rBegin() {\n        return new OrderedMapIterator(this._header._right || this._header, this._header, this, 1 /* IteratorType.REVERSE */);\n    }\n    rEnd() {\n        return new OrderedMapIterator(this._header, this._header, this, 1 /* IteratorType.REVERSE */);\n    }\n    front() {\n        if (this._length === 0)\n            return;\n        const minNode = this._header._left;\n        return [minNode._key, minNode._value];\n    }\n    back() {\n        if (this._length === 0)\n            return;\n        const maxNode = this._header._right;\n        return [maxNode._key, maxNode._value];\n    }\n    lowerBound(key) {\n        const resNode = this._lowerBound(this._root, key);\n        return new OrderedMapIterator(resNode, this._header, this);\n    }\n    upperBound(key) {\n        const resNode = this._upperBound(this._root, key);\n        return new OrderedMapIterator(resNode, this._header, this);\n    }\n    reverseLowerBound(key) {\n        const resNode = this._reverseLowerBound(this._root, key);\n        return new OrderedMapIterator(resNode, this._header, this);\n    }\n    reverseUpperBound(key) {\n        const resNode = this._reverseUpperBound(this._root, key);\n        return new OrderedMapIterator(resNode, this._header, this);\n    }\n    forEach(callback) {\n        this._inOrderTraversal(function (node, index, map) {\n            callback([node._key, node._value], index, map);\n        });\n    }\n    /**\n     * @description Insert a key-value pair or set value by the given key.\n     * @param key - The key want to insert.\n     * @param value - The value want to set.\n     * @param hint - You can give an iterator hint to improve insertion efficiency.\n     * @return The size of container after setting.\n     * @example\n     * const mp = new OrderedMap([[2, 0], [4, 0], [5, 0]]);\n     * const iter = mp.begin();\n     * mp.setElement(1, 0);\n     * mp.setElement(3, 0, iter);  // give a hint will be faster.\n     */\n    setElement(key, value, hint) {\n        return this._set(key, value, hint);\n    }\n    getElementByPos(pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        const node = this._inOrderTraversal(pos);\n        return [node._key, node._value];\n    }\n    find(key) {\n        const curNode = this._getTreeNodeByKey(this._root, key);\n        return new OrderedMapIterator(curNode, this._header, this);\n    }\n    /**\n     * @description Get the value of the element of the specified key.\n     * @param key - The specified key you want to get.\n     * @example\n     * const val = container.getElementByKey(1);\n     */\n    getElementByKey(key) {\n        const curNode = this._getTreeNodeByKey(this._root, key);\n        return curNode._value;\n    }\n    union(other) {\n        const self = this;\n        other.forEach(function (el) {\n            self.setElement(el[0], el[1]);\n        });\n        return this._length;\n    }\n    *[Symbol.iterator]() {\n        const length = this._length;\n        const nodeList = this._inOrderTraversal();\n        for (let i = 0; i < length; ++i) {\n            const node = nodeList[i];\n            yield [node._key, node._value];\n        }\n    }\n}\nexport default OrderedMap;\n","import TreeContainer from './Base';\nimport TreeIterator from './Base/TreeIterator';\nimport { TreeNode } from './Base/TreeNode';\nimport { initContainer, IteratorType } from '@/container/ContainerBase';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nclass OrderedMapIterator<K, V> extends TreeIterator<K, V> {\n  container: OrderedMap<K, V>;\n  constructor(\n    node: TreeNode<K, V>,\n    header: TreeNode<K, V>,\n    container: OrderedMap<K, V>,\n    iteratorType?: IteratorType\n  ) {\n    super(node, header, iteratorType);\n    this.container = container;\n  }\n  get pointer() {\n    if (this._node === this._header) {\n      throwIteratorAccessError();\n    }\n    const self = this;\n    return new Proxy(<[K, V]><unknown>[], {\n      get(_, props: '0' | '1') {\n        if (props === '0') return self._node._key;\n        else if (props === '1') return self._node._value;\n      },\n      set(_, props: '1', newValue: V) {\n        if (props !== '1') {\n          throw new TypeError('props must be 1');\n        }\n        self._node._value = newValue;\n        return true;\n      }\n    });\n  }\n  copy() {\n    return new OrderedMapIterator<K, V>(\n      this._node,\n      this._header,\n      this.container,\n      this.iteratorType\n    );\n  }\n  // @ts-ignore\n  equals(iter: OrderedMapIterator<K, V>): boolean;\n}\n\nexport type { OrderedMapIterator };\n\nclass OrderedMap<K, V> extends TreeContainer<K, V> {\n  /**\n   * @param container - The initialization container.\n   * @param cmp - The compare function.\n   * @param enableIndex - Whether to enable iterator indexing function.\n   * @example\n   * new OrderedMap();\n   * new OrderedMap([[0, 1], [2, 1]]);\n   * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y);\n   * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y, true);\n   */\n  constructor(\n    container: initContainer<[K, V]> = [],\n    cmp?: (x: K, y: K) => number,\n    enableIndex?: boolean\n  ) {\n    super(cmp, enableIndex);\n    const self = this;\n    container.forEach(function (el) {\n      self.setElement(el[0], el[1]);\n    });\n  }\n  begin() {\n    return new OrderedMapIterator<K, V>(this._header._left || this._header, this._header, this);\n  }\n  end() {\n    return new OrderedMapIterator<K, V>(this._header, this._header, this);\n  }\n  rBegin() {\n    return new OrderedMapIterator<K, V>(\n      this._header._right || this._header,\n      this._header,\n      this,\n      IteratorType.REVERSE\n    );\n  }\n  rEnd() {\n    return new OrderedMapIterator<K, V>(this._header, this._header, this, IteratorType.REVERSE);\n  }\n  front() {\n    if (this._length === 0) return;\n    const minNode = this._header._left!;\n    return <[K, V]>[minNode._key, minNode._value];\n  }\n  back() {\n    if (this._length === 0) return;\n    const maxNode = this._header._right!;\n    return <[K, V]>[maxNode._key, maxNode._value];\n  }\n  lowerBound(key: K) {\n    const resNode = this._lowerBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  upperBound(key: K) {\n    const resNode = this._upperBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  reverseLowerBound(key: K) {\n    const resNode = this._reverseLowerBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  reverseUpperBound(key: K) {\n    const resNode = this._reverseUpperBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  forEach(callback: (element: [K, V], index: number, map: OrderedMap<K, V>) => void) {\n    this._inOrderTraversal(function (node, index, map) {\n      callback(<[K, V]>[node._key, node._value], index, map);\n    });\n  }\n  /**\n   * @description Insert a key-value pair or set value by the given key.\n   * @param key - The key want to insert.\n   * @param value - The value want to set.\n   * @param hint - You can give an iterator hint to improve insertion efficiency.\n   * @return The size of container after setting.\n   * @example\n   * const mp = new OrderedMap([[2, 0], [4, 0], [5, 0]]);\n   * const iter = mp.begin();\n   * mp.setElement(1, 0);\n   * mp.setElement(3, 0, iter);  // give a hint will be faster.\n   */\n  setElement(key: K, value: V, hint?: OrderedMapIterator<K, V>) {\n    return this._set(key, value, hint);\n  }\n  getElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    const node = this._inOrderTraversal(pos);\n    return <[K, V]>[node._key, node._value];\n  }\n  find(key: K) {\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    return new OrderedMapIterator<K, V>(curNode, this._header, this);\n  }\n  /**\n   * @description Get the value of the element of the specified key.\n   * @param key - The specified key you want to get.\n   * @example\n   * const val = container.getElementByKey(1);\n   */\n  getElementByKey(key: K) {\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    return curNode._value;\n  }\n  union(other: OrderedMap<K, V>) {\n    const self = this;\n    other.forEach(function (el) {\n      self.setElement(el[0], el[1]);\n    });\n    return this._length;\n  }\n  * [Symbol.iterator]() {\n    const length = this._length;\n    const nodeList = this._inOrderTraversal();\n    for (let i = 0; i < length; ++i) {\n      const node = nodeList[i];\n      yield <[K, V]>[node._key, node._value];\n    }\n  }\n  // @ts-ignore\n  eraseElementByIterator(iter: OrderedMapIterator<K, V>): OrderedMapIterator<K, V>;\n}\n\nexport default OrderedMap;\n"]}