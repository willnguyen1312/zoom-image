{"version":3,"file":"index.production.js","sources":["../../../autocomplete-shared/dist/esm/flatten.js","../../../autocomplete-shared/dist/esm/generateAutocompleteId.js","../../../autocomplete-shared/dist/esm/getItemsCount.js","../../../autocomplete-shared/dist/esm/noop.js","../../../autocomplete-shared/dist/esm/userAgents.js","../../../autocomplete-shared/dist/esm/version.js","../../src/utils/createCancelablePromise.ts","../../src/utils/getNextActiveItemId.ts","../../src/utils/getActiveItem.ts","../../src/utils/isSamsung.ts","../../src/getDefaultProps.ts","../../src/utils/getNormalizedSources.ts","../../src/resolve.ts","../../src/utils/mapToAlgoliaResponse.ts","../../src/utils/createConcurrentSafePromise.ts","../../src/onInput.ts","../../src/reshape.ts","../../src/getPropGetters.ts","../../src/utils/isOrContainsNode.ts","../../src/onKeyDown.ts","../../src/metadata.ts","../../src/getCompletion.ts","../../src/stateReducer.ts","../../src/createAutocomplete.ts","../../src/createStore.ts","../../src/utils/createCancelablePromiseList.ts","../../src/getAutocompleteSetters.ts"],"sourcesContent":["export function flatten(values) {\n  return values.reduce(function (a, b) {\n    return a.concat(b);\n  }, []);\n}","var autocompleteId = 0;\nexport function generateAutocompleteId() {\n  return \"autocomplete-\".concat(autocompleteId++);\n}","export function getItemsCount(state) {\n  if (state.collections.length === 0) {\n    return 0;\n  }\n\n  return state.collections.reduce(function (sum, collection) {\n    return sum + collection.items.length;\n  }, 0);\n}","export var noop = function noop() {};","import { version } from './version';\nexport var userAgents = [{\n  segment: 'autocomplete-core',\n  version: version\n}];","export var version = '1.8.2';","type PromiseExecutor<TValue> = (\n  resolve: (value: TValue | PromiseLike<TValue>) => void,\n  reject: (reason?: any) => void\n) => void;\n\ntype CancelablePromiseState = {\n  isCanceled: boolean;\n  onCancelList: Array<(...args: any[]) => any>;\n};\n\nfunction createInternalCancelablePromise<TValue>(\n  promise: Promise<TValue>,\n  initialState: CancelablePromiseState\n): CancelablePromise<TValue> {\n  const state = initialState;\n\n  return {\n    then(onfulfilled, onrejected) {\n      return createInternalCancelablePromise(\n        promise.then(\n          createCallback(onfulfilled, state, promise),\n          createCallback(onrejected, state, promise)\n        ),\n        state\n      );\n    },\n    catch(onrejected) {\n      return createInternalCancelablePromise(\n        promise.catch(createCallback(onrejected, state, promise)),\n        state\n      );\n    },\n    finally(onfinally) {\n      if (onfinally) {\n        state.onCancelList.push(onfinally);\n      }\n\n      return createInternalCancelablePromise<TValue>(\n        promise.finally(\n          createCallback(\n            onfinally &&\n              (() => {\n                state.onCancelList = [];\n\n                return onfinally();\n              }),\n            state,\n            promise\n          )\n        ),\n        state\n      );\n    },\n    cancel() {\n      state.isCanceled = true;\n      const callbacks = state.onCancelList;\n      state.onCancelList = [];\n\n      callbacks.forEach((callback) => {\n        callback();\n      });\n    },\n    isCanceled() {\n      return state.isCanceled === true;\n    },\n  };\n}\n\nexport type CancelablePromise<TValue> = {\n  then<TResultFulfilled = TValue, TResultRejected = never>(\n    onfulfilled?:\n      | ((\n          value: TValue\n        ) =>\n          | TResultFulfilled\n          | PromiseLike<TResultFulfilled>\n          | CancelablePromise<TResultFulfilled>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((\n          reason: any\n        ) =>\n          | TResultRejected\n          | PromiseLike<TResultRejected>\n          | CancelablePromise<TResultRejected>)\n      | undefined\n      | null\n  ): CancelablePromise<TResultFulfilled | TResultRejected>;\n  catch<TResult = never>(\n    onrejected?:\n      | ((\n          reason: any\n        ) => TResult | PromiseLike<TResult> | CancelablePromise<TResult>)\n      | undefined\n      | null\n  ): CancelablePromise<TValue | TResult>;\n  finally(\n    onfinally?: (() => void) | undefined | null\n  ): CancelablePromise<TValue>;\n  cancel(): void;\n  isCanceled(): boolean;\n};\n\nexport function createCancelablePromise<TValue>(\n  executor: PromiseExecutor<TValue>\n): CancelablePromise<TValue> {\n  return createInternalCancelablePromise(\n    new Promise<TValue>((resolve, reject) => {\n      return executor(resolve, reject);\n    }),\n    { isCanceled: false, onCancelList: [] }\n  );\n}\n\ncreateCancelablePromise.resolve = <TValue>(\n  value?: TValue | PromiseLike<TValue> | CancelablePromise<TValue>\n) => cancelable(Promise.resolve(value));\n\ncreateCancelablePromise.reject = (reason?: any) =>\n  cancelable(Promise.reject(reason));\n\nexport function cancelable<TValue>(promise: Promise<TValue>) {\n  return createInternalCancelablePromise(promise, {\n    isCanceled: false,\n    onCancelList: [],\n  });\n}\n\nfunction createCallback(\n  onResult: ((...args: any[]) => any) | null | undefined,\n  state: CancelablePromiseState,\n  fallback: any\n) {\n  if (!onResult) {\n    return fallback;\n  }\n\n  return function callback(arg?: any) {\n    if (state.isCanceled) {\n      return arg;\n    }\n\n    return onResult(arg);\n  };\n}\n","/**\n * Returns the next active item ID from the current state.\n *\n * We allow circular keyboard navigation from the base index.\n * The base index can either be `null` (nothing is highlighted) or `0`\n * (the first item is highlighted).\n * The base index is allowed to get assigned `null` only if\n * `props.defaultActiveItemId` is `null`. This pattern allows to \"stop\"\n * by the actual query before navigating to other suggestions as seen on\n * Google or Amazon.\n *\n * @param moveAmount The offset to increment (or decrement) the last index\n * @param baseIndex The current index to compute the next index from\n * @param itemCount The number of items\n * @param defaultActiveItemId The default active index to fallback to\n */\nexport function getNextActiveItemId(\n  moveAmount: number,\n  baseIndex: number | null,\n  itemCount: number,\n  defaultActiveItemId: number | null\n): number | null {\n  if (!itemCount) {\n    return null;\n  }\n\n  if (\n    moveAmount < 0 &&\n    (baseIndex === null || (defaultActiveItemId !== null && baseIndex === 0))\n  ) {\n    return itemCount + moveAmount;\n  }\n\n  const numericIndex = (baseIndex === null ? -1 : baseIndex) + moveAmount;\n\n  if (numericIndex <= -1 || numericIndex >= itemCount) {\n    return defaultActiveItemId === null ? null : 0;\n  }\n\n  return numericIndex;\n}\n","import { AutocompleteCollection, AutocompleteState, BaseItem } from '../types';\n\n// We don't have access to the autocomplete source when we call `onKeyDown`\n// or `onClick` because those are native browser events.\n// However, we can get the source from the suggestion index.\nfunction getCollectionFromActiveItemId<TItem extends BaseItem>(\n  state: AutocompleteState<TItem>\n): AutocompleteCollection<TItem> | undefined {\n  // Given 3 sources with respectively 1, 2 and 3 suggestions: [1, 2, 3]\n  // We want to get the accumulated counts:\n  // [1, 1 + 2, 1 + 2 + 3] = [1, 3, 3 + 3] = [1, 3, 6]\n  const accumulatedCollectionsCount = state.collections\n    .map((collections) => collections.items.length)\n    .reduce<number[]>((acc, collectionsCount, index) => {\n      const previousValue = acc[index - 1] || 0;\n      const nextValue = previousValue + collectionsCount;\n\n      acc.push(nextValue);\n\n      return acc;\n    }, []);\n\n  // Based on the accumulated counts, we can infer the index of the suggestion.\n  const collectionIndex = accumulatedCollectionsCount.reduce((acc, current) => {\n    if (current <= state.activeItemId!) {\n      return acc + 1;\n    }\n\n    return acc;\n  }, 0);\n\n  return state.collections[collectionIndex];\n}\n\n/**\n * Gets the highlighted index relative to a suggestion object (not the absolute\n * highlighted index).\n *\n * Example:\n *  [['a', 'b'], ['c', 'd', 'e'], ['f']]\n *                      â†‘\n *         (absolute: 3, relative: 1)\n */\nfunction getRelativeActiveItemId<TItem extends BaseItem>({\n  state,\n  collection,\n}: {\n  state: AutocompleteState<TItem>;\n  collection: AutocompleteCollection<TItem>;\n}): number {\n  let isOffsetFound = false;\n  let counter = 0;\n  let previousItemsOffset = 0;\n\n  while (isOffsetFound === false) {\n    const currentCollection = state.collections[counter];\n\n    if (currentCollection === collection) {\n      isOffsetFound = true;\n      break;\n    }\n\n    previousItemsOffset += currentCollection.items.length;\n\n    counter++;\n  }\n\n  return state.activeItemId! - previousItemsOffset;\n}\n\nexport function getActiveItem<TItem extends BaseItem>(\n  state: AutocompleteState<TItem>\n) {\n  const collection = getCollectionFromActiveItemId(state);\n\n  if (!collection) {\n    return null;\n  }\n\n  const item = collection.items[getRelativeActiveItemId({ state, collection })];\n  const source = collection.source;\n  const itemInputValue = source.getItemInputValue({ item, state });\n  const itemUrl = source.getItemUrl({ item, state });\n\n  return {\n    item,\n    itemInputValue,\n    itemUrl,\n    source,\n  };\n}\n","const regex = /((gt|sm)-|galaxy nexus)|samsung[- ]/i;\n\nexport function isSamsung(userAgent: string) {\n  return Boolean(userAgent && userAgent.match(regex));\n}\n","import {\n  getItemsCount,\n  generateAutocompleteId,\n  flatten,\n} from '@algolia/autocomplete-shared';\n\nimport {\n  AutocompleteEnvironment,\n  AutocompleteOptions,\n  AutocompleteSubscribers,\n  BaseItem,\n  InternalAutocompleteOptions,\n} from './types';\nimport { getNormalizedSources } from './utils';\n\nexport function getDefaultProps<TItem extends BaseItem>(\n  props: AutocompleteOptions<TItem>,\n  pluginSubscribers: AutocompleteSubscribers<TItem>\n): InternalAutocompleteOptions<TItem> {\n  /* eslint-disable no-restricted-globals */\n  const environment: AutocompleteEnvironment = (typeof window !== 'undefined'\n    ? window\n    : {}) as typeof window;\n  /* eslint-enable no-restricted-globals */\n  const plugins = props.plugins || [];\n\n  return {\n    debug: false,\n    openOnFocus: false,\n    placeholder: '',\n    autoFocus: false,\n    defaultActiveItemId: null,\n    stallThreshold: 300,\n    environment,\n    shouldPanelOpen: ({ state }) => getItemsCount(state) > 0,\n    reshape: ({ sources }) => sources,\n    ...props,\n    // Since `generateAutocompleteId` triggers a side effect (it increments\n    // an internal counter), we don't want to execute it if unnecessary.\n    id: props.id ?? generateAutocompleteId(),\n    plugins,\n    // The following props need to be deeply defaulted.\n    initialState: {\n      activeItemId: null,\n      query: '',\n      completion: null,\n      collections: [],\n      isOpen: false,\n      status: 'idle',\n      context: {},\n      ...props.initialState,\n    },\n    onStateChange(params) {\n      props.onStateChange?.(params);\n      plugins.forEach((x) => x.onStateChange?.(params));\n    },\n    onSubmit(params) {\n      props.onSubmit?.(params);\n      plugins.forEach((x) => x.onSubmit?.(params));\n    },\n    onReset(params) {\n      props.onReset?.(params);\n      plugins.forEach((x) => x.onReset?.(params));\n    },\n    getSources(params) {\n      return Promise.all(\n        [...plugins.map((plugin) => plugin.getSources), props.getSources]\n          .filter(Boolean)\n          .map((getSources) => getNormalizedSources(getSources!, params))\n      )\n        .then((nested) => flatten(nested))\n        .then((sources) =>\n          sources.map((source) => ({\n            ...source,\n            onSelect(params) {\n              source.onSelect(params);\n              pluginSubscribers.forEach((x) => x.onSelect?.(params));\n            },\n            onActive(params) {\n              source.onActive(params);\n              pluginSubscribers.forEach((x) => x.onActive?.(params));\n            },\n            onResolve(params) {\n              source.onResolve(params);\n              pluginSubscribers.forEach((x) => x.onResolve?.(params));\n            },\n          }))\n        );\n    },\n    navigator: {\n      navigate({ itemUrl }) {\n        environment.location.assign(itemUrl);\n      },\n      navigateNewTab({ itemUrl }) {\n        const windowReference = environment.open(itemUrl, '_blank', 'noopener');\n        windowReference?.focus();\n      },\n      navigateNewWindow({ itemUrl }) {\n        environment.open(itemUrl, '_blank', 'noopener');\n      },\n      ...props.navigator,\n    },\n  };\n}\n","import { invariant, decycle, noop } from '@algolia/autocomplete-shared';\n\nimport {\n  AutocompleteSource,\n  BaseItem,\n  GetSources,\n  GetSourcesParams,\n  InternalAutocompleteSource,\n  InternalGetSources,\n} from '../types';\n\nexport function getNormalizedSources<TItem extends BaseItem>(\n  getSources: GetSources<TItem>,\n  params: GetSourcesParams<TItem>\n): ReturnType<InternalGetSources<TItem>> {\n  const seenSourceIds: string[] = [];\n\n  return Promise.resolve(getSources(params)).then((sources) => {\n    invariant(\n      Array.isArray(sources),\n      () =>\n        `The \\`getSources\\` function must return an array of sources but returned type ${JSON.stringify(\n          typeof sources\n        )}:\\n\\n${JSON.stringify(decycle(sources), null, 2)}`\n    );\n\n    return Promise.all(\n      sources\n        // We allow `undefined` and `false` sources to allow users to use\n        // `Boolean(query) && source` (=> `false`).\n        // We need to remove these values at this point.\n        .filter((maybeSource: any): maybeSource is AutocompleteSource<TItem> =>\n          Boolean(maybeSource)\n        )\n        .map((source) => {\n          invariant(\n            typeof source.sourceId === 'string',\n            'A source must provide a `sourceId` string.'\n          );\n\n          if (seenSourceIds.includes(source.sourceId)) {\n            throw new Error(\n              `[Autocomplete] The \\`sourceId\\` ${JSON.stringify(\n                source.sourceId\n              )} is not unique.`\n            );\n          }\n\n          seenSourceIds.push(source.sourceId);\n\n          const defaultSource: Omit<\n            InternalAutocompleteSource<TItem>,\n            'sourceId' | 'getItems'\n          > = {\n            getItemInputValue({ state }) {\n              return state.query;\n            },\n            getItemUrl() {\n              return undefined;\n            },\n            onSelect({ setIsOpen }) {\n              setIsOpen(false);\n            },\n            onActive: noop,\n            onResolve: noop,\n          };\n\n          Object.keys(defaultSource).forEach((key) => {\n            defaultSource[key].__default = true;\n          });\n\n          const normalizedSource: InternalAutocompleteSource<TItem> = {\n            ...defaultSource,\n            ...source,\n          };\n\n          return Promise.resolve(normalizedSource);\n        })\n    );\n  });\n}\n","import type {\n  Execute,\n  ExecuteResponse,\n  RequesterDescription,\n  TransformResponse,\n} from '@algolia/autocomplete-preset-algolia';\nimport { decycle, flatten, invariant } from '@algolia/autocomplete-shared';\nimport {\n  MultipleQueriesQuery,\n  SearchForFacetValuesResponse,\n  SearchResponse,\n} from '@algolia/client-search';\nimport type { SearchClient } from 'algoliasearch/lite';\n\nimport {\n  AutocompleteState,\n  AutocompleteStore,\n  BaseItem,\n  InternalAutocompleteSource,\n  OnResolveParams,\n} from './types';\nimport { mapToAlgoliaResponse } from './utils';\n\nfunction isDescription<TItem extends BaseItem>(\n  item:\n    | RequestDescriptionPreResolved<TItem>\n    | RequestDescriptionPreResolvedCustom<TItem>\n    | PackedDescription<TItem>\n): item is RequestDescriptionPreResolved<TItem> {\n  return Boolean((item as RequestDescriptionPreResolved<TItem>).execute);\n}\n\nfunction isRequesterDescription<TItem extends BaseItem>(\n  description: TItem[] | TItem[][] | RequesterDescription<TItem>\n): description is RequesterDescription<TItem> {\n  return Boolean((description as RequesterDescription<TItem>)?.execute);\n}\n\ntype PackedDescription<TItem extends BaseItem> = {\n  searchClient: SearchClient;\n  execute: Execute<TItem>;\n  requesterId?: string;\n  items: RequestDescriptionPreResolved<TItem>['requests'];\n};\n\ntype RequestDescriptionPreResolved<TItem extends BaseItem> = Pick<\n  RequesterDescription<TItem>,\n  'execute' | 'requesterId' | 'searchClient' | 'transformResponse'\n> & {\n  requests: Array<{\n    query: MultipleQueriesQuery;\n    sourceId: string;\n    transformResponse: TransformResponse<TItem>;\n  }>;\n};\n\ntype RequestDescriptionPreResolvedCustom<TItem extends BaseItem> = {\n  items: TItem[] | TItem[][];\n  sourceId: string;\n  transformResponse?: undefined;\n};\n\nexport function preResolve<TItem extends BaseItem>(\n  itemsOrDescription: TItem[] | TItem[][] | RequesterDescription<TItem>,\n  sourceId: string,\n  state: AutocompleteState<TItem>\n):\n  | RequestDescriptionPreResolved<TItem>\n  | RequestDescriptionPreResolvedCustom<TItem> {\n  if (isRequesterDescription<TItem>(itemsOrDescription)) {\n    const contextParameters =\n      itemsOrDescription.requesterId === 'algolia'\n        ? Object.assign(\n            {},\n            ...Object.keys(state.context).map((key) => {\n              return (state.context[key] as Record<string, unknown>)\n                ?.__algoliaSearchParameters;\n            })\n          )\n        : {};\n\n    return {\n      ...itemsOrDescription,\n      requests: itemsOrDescription.queries.map((query) => ({\n        query:\n          itemsOrDescription.requesterId === 'algolia'\n            ? {\n                ...query,\n                params: {\n                  ...contextParameters,\n                  ...query.params,\n                },\n              }\n            : query,\n        sourceId,\n        transformResponse: itemsOrDescription.transformResponse,\n      })),\n    };\n  }\n\n  return {\n    items: itemsOrDescription,\n    sourceId,\n  };\n}\n\nexport function resolve<TItem extends BaseItem>(\n  items: Array<\n    | RequestDescriptionPreResolved<TItem>\n    | RequestDescriptionPreResolvedCustom<TItem>\n  >\n) {\n  const packed = items.reduce<\n    Array<RequestDescriptionPreResolvedCustom<TItem> | PackedDescription<TItem>>\n  >((acc, current) => {\n    if (!isDescription(current)) {\n      acc.push(current);\n      return acc;\n    }\n\n    const { searchClient, execute, requesterId, requests } = current;\n\n    const container = acc.find<PackedDescription<TItem>>(\n      (item): item is PackedDescription<TItem> => {\n        return (\n          isDescription(current) &&\n          isDescription(item) &&\n          item.searchClient === searchClient &&\n          Boolean(requesterId) &&\n          item.requesterId === requesterId\n        );\n      }\n    );\n\n    if (container) {\n      container.items.push(...requests);\n    } else {\n      const request: PackedDescription<TItem> = {\n        execute,\n        requesterId,\n        items: requests,\n        searchClient,\n      };\n      acc.push(request);\n    }\n\n    return acc;\n  }, []);\n\n  const values = packed.map<\n    | Promise<RequestDescriptionPreResolvedCustom<TItem>>\n    | ReturnType<Execute<TItem>>\n  >((maybeDescription) => {\n    if (!isDescription<TItem>(maybeDescription)) {\n      return Promise.resolve(\n        maybeDescription as RequestDescriptionPreResolvedCustom<TItem>\n      );\n    }\n\n    const {\n      execute,\n      items,\n      searchClient,\n    } = maybeDescription as PackedDescription<TItem>;\n\n    return execute({\n      searchClient,\n      requests: items,\n    });\n  });\n\n  return Promise.all<\n    RequestDescriptionPreResolvedCustom<TItem> | ExecuteResponse<TItem>\n  >(values).then((responses) =>\n    flatten<\n      RequestDescriptionPreResolvedCustom<TItem> | ExecuteResponse<TItem>[0]\n    >(responses)\n  );\n}\n\nexport function postResolve<TItem extends BaseItem>(\n  responses: Array<\n    RequestDescriptionPreResolvedCustom<TItem> | ExecuteResponse<TItem>[0]\n  >,\n  sources: Array<InternalAutocompleteSource<TItem>>,\n  store: AutocompleteStore<TItem>\n) {\n  return sources.map((source) => {\n    const matches = responses.filter(\n      (response) => response.sourceId === source.sourceId\n    );\n    const results = matches.map(({ items }) => items);\n    const transform = matches[0].transformResponse;\n    const items = transform\n      ? transform(\n          mapToAlgoliaResponse(\n            results as Array<\n              SearchForFacetValuesResponse | SearchResponse<TItem>\n            >\n          )\n        )\n      : results;\n\n    source.onResolve({\n      source,\n      results,\n      items,\n      state: store.getState(),\n    } as OnResolveParams<TItem>);\n\n    invariant(\n      Array.isArray(items),\n      () => `The \\`getItems\\` function from source \"${\n        source.sourceId\n      }\" must return an array of items but returned type ${JSON.stringify(\n        typeof items\n      )}:\\n\\n${JSON.stringify(decycle(items), null, 2)}.\n\nSee: https://www.algolia.com/doc/ui-libraries/autocomplete/core-concepts/sources/#param-getitems`\n    );\n\n    invariant(\n      (items as Array<typeof items>).every(Boolean),\n      `The \\`getItems\\` function from source \"${\n        source.sourceId\n      }\" must return an array of items but returned ${JSON.stringify(\n        undefined\n      )}.\n\nDid you forget to return items?\n\nSee: https://www.algolia.com/doc/ui-libraries/autocomplete/core-concepts/sources/#param-getitems`\n    );\n\n    return {\n      source,\n      items,\n    };\n  });\n}\n","import type {\n  SearchForFacetValuesResponse,\n  SearchResponse,\n} from '@algolia/client-search';\n\nexport function mapToAlgoliaResponse<THit>(\n  rawResults: Array<SearchResponse<THit> | SearchForFacetValuesResponse>\n) {\n  const results: Array<\n    SearchResponse<THit> | SearchForFacetValuesResponse\n  > = rawResults.map((result) => {\n    return {\n      ...result,\n      hits: (result as SearchResponse<THit>).hits?.map((hit) => {\n        // Bring support for the Insights plugin.\n        return {\n          ...hit,\n          __autocomplete_indexName: (result as SearchResponse<THit>).index,\n          __autocomplete_queryID: (result as SearchResponse<THit>).queryID,\n        };\n      }),\n    };\n  });\n\n  return {\n    results,\n    hits: results\n      .map((result) => (result as SearchResponse<THit>).hits)\n      .filter(Boolean),\n    facetHits: results\n      .map((result) =>\n        (result as SearchForFacetValuesResponse).facetHits?.map((facetHit) => {\n          // Bring support for the highlighting components.\n          return {\n            label: facetHit.value,\n            count: facetHit.count,\n            _highlightResult: {\n              label: {\n                value: facetHit.highlighted,\n              },\n            },\n          };\n        })\n      )\n      .filter(Boolean),\n  };\n}\n","import { MaybePromise } from '@algolia/autocomplete-shared';\n\n/**\n * Creates a runner that executes promises in a concurrent-safe way.\n *\n * This is useful to prevent older promises to resolve after a newer promise,\n * otherwise resulting in stale resolved values.\n */\nexport function createConcurrentSafePromise() {\n  let basePromiseId = -1;\n  let latestResolvedId = -1;\n  let latestResolvedValue: unknown = undefined;\n\n  return function runConcurrentSafePromise<TValue>(\n    promise: MaybePromise<TValue>\n  ) {\n    basePromiseId++;\n    const currentPromiseId = basePromiseId;\n\n    return Promise.resolve(promise).then((x) => {\n      // The promise might take too long to resolve and get outdated. This would\n      // result in resolving stale values.\n      // When this happens, we ignore the promise value and return the one\n      // coming from the latest resolved value.\n      //\n      // +----------------------------------+\n      // |        100ms                     |\n      // | run(1) +--->  R1                 |\n      // |        300ms                     |\n      // | run(2) +-------------> R2 (SKIP) |\n      // |        200ms                     |\n      // | run(3) +--------> R3             |\n      // +----------------------------------+\n      if (latestResolvedValue && currentPromiseId < latestResolvedId) {\n        return latestResolvedValue as TValue;\n      }\n\n      latestResolvedId = currentPromiseId;\n      latestResolvedValue = x;\n\n      return x;\n    });\n  };\n}\n","import { reshape } from './reshape';\nimport { preResolve, resolve, postResolve } from './resolve';\nimport {\n  AutocompleteScopeApi,\n  AutocompleteState,\n  AutocompleteStore,\n  BaseItem,\n  InternalAutocompleteOptions,\n} from './types';\nimport {\n  cancelable,\n  CancelablePromise,\n  createConcurrentSafePromise,\n  getActiveItem,\n} from './utils';\n\nlet lastStalledId: number | null = null;\n\ninterface OnInputParams<TItem extends BaseItem>\n  extends AutocompleteScopeApi<TItem> {\n  event: any;\n  /**\n   * The next partial state to apply after the function is called.\n   *\n   * This is useful when we call `onInput` in a different scenario than an\n   * actual input. For example, we use `onInput` when we click on an item,\n   * but we want to close the panel in that case.\n   */\n  nextState?: Partial<AutocompleteState<TItem>>;\n  props: InternalAutocompleteOptions<TItem>;\n  query: string;\n  store: AutocompleteStore<TItem>;\n}\n\nconst runConcurrentSafePromise = createConcurrentSafePromise();\n\nexport function onInput<TItem extends BaseItem>({\n  event,\n  nextState = {},\n  props,\n  query,\n  refresh,\n  store,\n  ...setters\n}: OnInputParams<TItem>): CancelablePromise<void> {\n  if (lastStalledId) {\n    props.environment.clearTimeout(lastStalledId);\n  }\n\n  const {\n    setCollections,\n    setIsOpen,\n    setQuery,\n    setActiveItemId,\n    setStatus,\n  } = setters;\n\n  setQuery(query);\n  setActiveItemId(props.defaultActiveItemId);\n\n  if (!query && props.openOnFocus === false) {\n    const collections = store.getState().collections.map((collection) => ({\n      ...collection,\n      items: [],\n    }));\n\n    setStatus('idle');\n    setCollections(collections);\n    setIsOpen(\n      nextState.isOpen ?? props.shouldPanelOpen({ state: store.getState() })\n    );\n\n    // We make sure to update the latest resolved value of the tracked\n    // promises to keep late resolving promises from \"cancelling\" the state\n    // updates performed in this code path.\n    // We chain with a void promise to respect `onInput`'s expected return type.\n    const request = cancelable(\n      runConcurrentSafePromise(collections).then(() => Promise.resolve())\n    );\n\n    return store.pendingRequests.add(request);\n  }\n\n  setStatus('loading');\n\n  lastStalledId = props.environment.setTimeout(() => {\n    setStatus('stalled');\n  }, props.stallThreshold);\n\n  // We track the entire promise chain triggered by `onInput` before mutating\n  // the Autocomplete state to make sure that any state manipulation is based on\n  // fresh data regardless of when promises individually resolve.\n  // We don't track nested promises and only rely on the full chain resolution,\n  // meaning we should only ever manipulate the state once this concurrent-safe\n  // promise is resolved.\n  const request = cancelable(\n    runConcurrentSafePromise(\n      props\n        .getSources({\n          query,\n          refresh,\n          state: store.getState(),\n          ...setters,\n        })\n        .then((sources) => {\n          return Promise.all(\n            sources.map((source) => {\n              return Promise.resolve(\n                source.getItems({\n                  query,\n                  refresh,\n                  state: store.getState(),\n                  ...setters,\n                })\n              ).then((itemsOrDescription) =>\n                preResolve<TItem>(\n                  itemsOrDescription,\n                  source.sourceId,\n                  store.getState()\n                )\n              );\n            })\n          )\n            .then(resolve)\n            .then((responses) => postResolve(responses, sources, store))\n            .then((collections) =>\n              reshape({ collections, props, state: store.getState() })\n            );\n        })\n    )\n  )\n    .then((collections) => {\n      // Parameters passed to `onInput` could be stale when the following code\n      // executes, because `onInput` calls may not resolve in order.\n      // If it becomes a problem we'll need to save the last passed parameters.\n      // See: https://codesandbox.io/s/agitated-cookies-y290z\n\n      setStatus('idle');\n\n      setCollections(collections as any);\n\n      const isPanelOpen = props.shouldPanelOpen({ state: store.getState() });\n\n      setIsOpen(\n        nextState.isOpen ??\n          ((props.openOnFocus && !query && isPanelOpen) || isPanelOpen)\n      );\n\n      const highlightedItem = getActiveItem(store.getState());\n\n      if (store.getState().activeItemId !== null && highlightedItem) {\n        const { item, itemInputValue, itemUrl, source } = highlightedItem;\n\n        source.onActive({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n      }\n    })\n    .finally(() => {\n      setStatus('idle');\n\n      if (lastStalledId) {\n        props.environment.clearTimeout(lastStalledId);\n      }\n    });\n\n  return store.pendingRequests.add(request);\n}\n","import { flatten } from '@algolia/autocomplete-shared';\n\nimport {\n  AutocompleteCollection,\n  AutocompleteReshapeSourcesBySourceId,\n  AutocompleteState,\n  BaseItem,\n  InternalAutocompleteOptions,\n} from './types';\n\ntype ReshapeParams<TItem extends BaseItem> = {\n  collections: Array<AutocompleteCollection<any>>;\n  props: InternalAutocompleteOptions<TItem>;\n  state: AutocompleteState<TItem>;\n};\n\nexport function reshape<TItem extends BaseItem>({\n  collections,\n  props,\n  state,\n}: ReshapeParams<TItem>) {\n  // Sources are grouped by `sourceId` to conveniently pick them via destructuring.\n  // Example: `const { recentSearchesPlugin } = sourcesBySourceId`\n  const originalSourcesBySourceId = collections.reduce<\n    AutocompleteReshapeSourcesBySourceId<TItem>\n  >(\n    (acc, collection) => ({\n      ...acc,\n      [collection.source.sourceId]: {\n        ...collection.source,\n        getItems() {\n          // We provide the resolved items from the collection to the `reshape` prop.\n          return flatten<any>(collection.items);\n        },\n      },\n    }),\n    {}\n  );\n\n  const { sourcesBySourceId } = props.plugins.reduce(\n    (acc, plugin) => {\n      if (plugin.reshape) {\n        return plugin.reshape(acc);\n      }\n      return acc;\n    },\n    {\n      sourcesBySourceId: originalSourcesBySourceId,\n      state,\n    }\n  );\n\n  const reshapeSources = props.reshape({\n    sourcesBySourceId,\n    sources: Object.values(sourcesBySourceId),\n    state,\n  });\n\n  // We reconstruct the collections with the items modified by the `reshape` prop.\n  return flatten(reshapeSources)\n    .filter(Boolean)\n    .map((source) => {\n      return {\n        source,\n        items: source.getItems(),\n      };\n    });\n}\n","import { noop } from '@algolia/autocomplete-shared';\n\nimport { onInput } from './onInput';\nimport { onKeyDown } from './onKeyDown';\nimport {\n  AutocompleteScopeApi,\n  AutocompleteStore,\n  BaseItem,\n  GetEnvironmentProps,\n  GetFormProps,\n  GetInputProps,\n  GetItemProps,\n  GetLabelProps,\n  GetListProps,\n  GetPanelProps,\n  GetRootProps,\n  InternalAutocompleteOptions,\n} from './types';\nimport { getActiveItem, isOrContainsNode, isSamsung } from './utils';\n\ninterface GetPropGettersOptions<TItem extends BaseItem>\n  extends AutocompleteScopeApi<TItem> {\n  store: AutocompleteStore<TItem>;\n  props: InternalAutocompleteOptions<TItem>;\n}\n\nexport function getPropGetters<\n  TItem extends BaseItem,\n  TEvent,\n  TMouseEvent,\n  TKeyboardEvent\n>({ props, refresh, store, ...setters }: GetPropGettersOptions<TItem>) {\n  const getEnvironmentProps: GetEnvironmentProps = (providedProps) => {\n    const { inputElement, formElement, panelElement, ...rest } = providedProps;\n\n    function onMouseDownOrTouchStart(event: MouseEvent | TouchEvent) {\n      // The `onTouchStart`/`onMouseDown` events shouldn't trigger the `blur`\n      // handler when it's not an interaction with Autocomplete.\n      // We detect it with the following heuristics:\n      // - the panel is closed AND there are no pending requests\n      //   (no interaction with the autocomplete, no future state updates)\n      // - OR the touched target is the input element (should open the panel)\n      const isAutocompleteInteraction =\n        store.getState().isOpen || !store.pendingRequests.isEmpty();\n\n      if (!isAutocompleteInteraction || event.target === inputElement) {\n        return;\n      }\n\n      // @TODO: support cases where there are multiple Autocomplete instances.\n      // Right now, a second instance makes this computation return false.\n      const isTargetWithinAutocomplete = [formElement, panelElement].some(\n        (contextNode) => {\n          return isOrContainsNode(contextNode, event.target as Node);\n        }\n      );\n\n      if (isTargetWithinAutocomplete === false) {\n        store.dispatch('blur', null);\n\n        // If requests are still pending when the user closes the panel, they\n        // could reopen the panel once they resolve.\n        // We want to prevent any subsequent query from reopening the panel\n        // because it would result in an unsolicited UI behavior.\n        if (!props.debug) {\n          store.pendingRequests.cancelAll();\n        }\n      }\n    }\n\n    return {\n      // We do not rely on the native `blur` event of the input to close the\n      // panel, but rather on a custom `touchstart`/`mousedown` event outside\n      // of the autocomplete elements.\n      // This ensures we don't mistakenly interpret interactions within the\n      // autocomplete (but outside of the input) as a signal to close the panel.\n      // For example, clicking reset button causes an input blur, but if\n      // `openOnFocus=true`, it shouldn't close the panel.\n      // On touch devices, scrolling results (`touchmove`) causes an input blur\n      // but shouldn't close the panel.\n      onTouchStart: onMouseDownOrTouchStart,\n      onMouseDown: onMouseDownOrTouchStart,\n      // When scrolling on touch devices (mobiles, tablets, etc.), we want to\n      // mimic the native platform behavior where the input is blurred to\n      // hide the virtual keyboard. This gives more vertical space to\n      // discover all the suggestions showing up in the panel.\n      onTouchMove(event: TouchEvent) {\n        if (\n          store.getState().isOpen === false ||\n          inputElement !== props.environment.document.activeElement ||\n          event.target === inputElement\n        ) {\n          return;\n        }\n\n        inputElement.blur();\n      },\n      ...rest,\n    };\n  };\n\n  const getRootProps: GetRootProps = (rest) => {\n    return {\n      role: 'combobox',\n      'aria-expanded': store.getState().isOpen,\n      'aria-haspopup': 'listbox',\n      'aria-owns': store.getState().isOpen ? `${props.id}-list` : undefined,\n      'aria-labelledby': `${props.id}-label`,\n      ...rest,\n    };\n  };\n\n  const getFormProps: GetFormProps<TEvent> = (providedProps) => {\n    const { inputElement, ...rest } = providedProps;\n\n    return {\n      action: '',\n      noValidate: true,\n      role: 'search',\n      onSubmit: (event) => {\n        ((event as unknown) as Event).preventDefault();\n\n        props.onSubmit({\n          event,\n          refresh,\n          state: store.getState(),\n          ...setters,\n        });\n\n        store.dispatch('submit', null);\n        providedProps.inputElement?.blur();\n      },\n      onReset: (event) => {\n        ((event as unknown) as Event).preventDefault();\n\n        props.onReset({\n          event,\n          refresh,\n          state: store.getState(),\n          ...setters,\n        });\n\n        store.dispatch('reset', null);\n        providedProps.inputElement?.focus();\n      },\n      ...rest,\n    };\n  };\n\n  const getInputProps: GetInputProps<TEvent, TMouseEvent, TKeyboardEvent> = (\n    providedProps\n  ) => {\n    function onFocus(event: TEvent) {\n      // We want to trigger a query when `openOnFocus` is true\n      // because the panel should open with the current query.\n      if (props.openOnFocus || Boolean(store.getState().query)) {\n        onInput({\n          event,\n          props,\n          query: store.getState().completion || store.getState().query,\n          refresh,\n          store,\n          ...setters,\n        });\n      }\n\n      store.dispatch('focus', null);\n    }\n\n    const { inputElement, maxLength = 512, ...rest } = providedProps || {};\n    const activeItem = getActiveItem(store.getState());\n\n    const userAgent = props.environment.navigator?.userAgent || '';\n    const shouldFallbackKeyHint = isSamsung(userAgent);\n    const enterKeyHint =\n      activeItem?.itemUrl && !shouldFallbackKeyHint ? 'go' : 'search';\n\n    return {\n      'aria-autocomplete': 'both',\n      'aria-activedescendant':\n        store.getState().isOpen && store.getState().activeItemId !== null\n          ? `${props.id}-item-${store.getState().activeItemId}`\n          : undefined,\n      'aria-controls': store.getState().isOpen ? `${props.id}-list` : undefined,\n      'aria-labelledby': `${props.id}-label`,\n      value: store.getState().completion || store.getState().query,\n      id: `${props.id}-input`,\n      autoComplete: 'off',\n      autoCorrect: 'off',\n      autoCapitalize: 'off',\n      enterKeyHint,\n      spellCheck: 'false',\n      autoFocus: props.autoFocus,\n      placeholder: props.placeholder,\n      maxLength,\n      type: 'search',\n      onChange: (event) => {\n        onInput({\n          event,\n          props,\n          query: (((event as unknown) as Event)\n            .currentTarget as HTMLInputElement).value.slice(0, maxLength),\n          refresh,\n          store,\n          ...setters,\n        });\n      },\n      onKeyDown: (event) => {\n        onKeyDown({\n          event: (event as unknown) as KeyboardEvent,\n          props,\n          refresh,\n          store,\n          ...setters,\n        });\n      },\n      onFocus,\n      // We don't rely on the `blur` event.\n      // See explanation in `onTouchStart`/`onMouseDown`.\n      // @MAJOR See if we need to keep this handler.\n      onBlur: noop,\n      onClick: (event) => {\n        // When the panel is closed and you click on the input while\n        // the input is focused, the `onFocus` event is not triggered\n        // (default browser behavior).\n        // In an autocomplete context, it makes sense to open the panel in this\n        // case.\n        // We mimic this event by catching the `onClick` event which\n        // triggers the `onFocus` for the panel to open.\n        if (\n          providedProps.inputElement ===\n            props.environment.document.activeElement &&\n          !store.getState().isOpen\n        ) {\n          onFocus((event as unknown) as TEvent);\n        }\n      },\n      ...rest,\n    };\n  };\n\n  const getAutocompleteId = (instanceId: string, sourceId?: number) => {\n    return typeof sourceId !== 'undefined'\n      ? `${instanceId}-${sourceId}`\n      : instanceId;\n  };\n\n  const getLabelProps: GetLabelProps = (providedProps) => {\n    const { sourceIndex, ...rest } = providedProps || {};\n\n    return {\n      htmlFor: `${getAutocompleteId(props.id, sourceIndex)}-input`,\n      id: `${getAutocompleteId(props.id, sourceIndex)}-label`,\n      ...rest,\n    };\n  };\n\n  const getListProps: GetListProps = (providedProps) => {\n    const { sourceIndex, ...rest } = providedProps || {};\n\n    return {\n      role: 'listbox',\n      'aria-labelledby': `${getAutocompleteId(props.id, sourceIndex)}-label`,\n      id: `${getAutocompleteId(props.id, sourceIndex)}-list`,\n      ...rest,\n    };\n  };\n\n  const getPanelProps: GetPanelProps<TMouseEvent> = (rest) => {\n    return {\n      onMouseDown(event) {\n        // Prevents the `activeElement` from being changed to the panel so\n        // that the blur event is not triggered, otherwise it closes the\n        // panel.\n        ((event as unknown) as MouseEvent).preventDefault();\n      },\n      onMouseLeave() {\n        store.dispatch('mouseleave', null);\n      },\n      ...rest,\n    };\n  };\n\n  const getItemProps: GetItemProps<any, TMouseEvent> = (providedProps) => {\n    const { item, source, sourceIndex, ...rest } = providedProps;\n\n    return {\n      id: `${getAutocompleteId(props.id, sourceIndex as number)}-item-${\n        item.__autocomplete_id\n      }`,\n      role: 'option',\n      'aria-selected': store.getState().activeItemId === item.__autocomplete_id,\n      onMouseMove(event) {\n        if (item.__autocomplete_id === store.getState().activeItemId) {\n          return;\n        }\n\n        store.dispatch('mousemove', item.__autocomplete_id);\n\n        const activeItem = getActiveItem(store.getState());\n\n        if (store.getState().activeItemId !== null && activeItem) {\n          const { item, itemInputValue, itemUrl, source } = activeItem;\n\n          source.onActive({\n            event,\n            item,\n            itemInputValue,\n            itemUrl,\n            refresh,\n            source,\n            state: store.getState(),\n            ...setters,\n          });\n        }\n      },\n      onMouseDown(event) {\n        // Prevents the `activeElement` from being changed to the item so it\n        // can remain with the current `activeElement`.\n        ((event as unknown) as MouseEvent).preventDefault();\n      },\n      onClick(event) {\n        const itemInputValue = source.getItemInputValue({\n          item,\n          state: store.getState(),\n        });\n        const itemUrl = source.getItemUrl({\n          item,\n          state: store.getState(),\n        });\n\n        // If `getItemUrl` is provided, it means that the suggestion\n        // is a link, not plain text that aims at updating the query.\n        // We can therefore skip the state change because it will update\n        // the `activeItemId`, resulting in a UI flash, especially\n        // noticeable on mobile.\n        const runPreCommand = itemUrl\n          ? Promise.resolve()\n          : onInput({\n              event,\n              nextState: { isOpen: false },\n              props,\n              query: itemInputValue,\n              refresh,\n              store,\n              ...setters,\n            });\n\n        runPreCommand.then(() => {\n          source.onSelect({\n            event,\n            item,\n            itemInputValue,\n            itemUrl,\n            refresh,\n            source,\n            state: store.getState(),\n            ...setters,\n          });\n        });\n      },\n      ...rest,\n    };\n  };\n\n  return {\n    getEnvironmentProps,\n    getRootProps,\n    getFormProps,\n    getLabelProps,\n    getInputProps,\n    getPanelProps,\n    getListProps,\n    getItemProps,\n  };\n}\n","export function isOrContainsNode(parent: Node, child: Node) {\n  return parent === child || parent.contains(child);\n}\n","import { onInput } from './onInput';\nimport {\n  ActionType,\n  AutocompleteScopeApi,\n  AutocompleteStore,\n  BaseItem,\n  InternalAutocompleteOptions,\n} from './types';\nimport { getActiveItem } from './utils';\n\ninterface OnKeyDownOptions<TItem extends BaseItem>\n  extends AutocompleteScopeApi<TItem> {\n  event: KeyboardEvent;\n  props: InternalAutocompleteOptions<TItem>;\n  store: AutocompleteStore<TItem>;\n}\n\nexport function onKeyDown<TItem extends BaseItem>({\n  event,\n  props,\n  refresh,\n  store,\n  ...setters\n}: OnKeyDownOptions<TItem>): void {\n  if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {\n    // eslint-disable-next-line no-inner-declarations\n    function triggerScrollIntoView() {\n      const nodeItem = props.environment.document.getElementById(\n        `${props.id}-item-${store.getState().activeItemId}`\n      );\n\n      if (nodeItem) {\n        if ((nodeItem as any).scrollIntoViewIfNeeded) {\n          (nodeItem as any).scrollIntoViewIfNeeded(false);\n        } else {\n          nodeItem.scrollIntoView(false);\n        }\n      }\n    }\n\n    // eslint-disable-next-line no-inner-declarations\n    function triggerOnActive() {\n      const highlightedItem = getActiveItem(store.getState());\n\n      if (store.getState().activeItemId !== null && highlightedItem) {\n        const { item, itemInputValue, itemUrl, source } = highlightedItem;\n\n        source.onActive({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n      }\n    }\n\n    // Default browser behavior changes the caret placement on ArrowUp and\n    // ArrowDown.\n    event.preventDefault();\n\n    // When re-opening the panel, we need to split the logic to keep the actions\n    // synchronized as `onInput` returns a promise.\n    if (\n      store.getState().isOpen === false &&\n      (props.openOnFocus || Boolean(store.getState().query))\n    ) {\n      onInput({\n        event,\n        props,\n        query: store.getState().query,\n        refresh,\n        store,\n        ...setters,\n      }).then(() => {\n        store.dispatch(event.key as ActionType, {\n          nextActiveItemId: props.defaultActiveItemId,\n        });\n\n        triggerOnActive();\n        // Since we rely on the DOM, we need to wait for all the micro tasks to\n        // finish (which include re-opening the panel) to make sure all the\n        // elements are available.\n        setTimeout(triggerScrollIntoView, 0);\n      });\n    } else {\n      store.dispatch(event.key, {});\n\n      triggerOnActive();\n      triggerScrollIntoView();\n    }\n  } else if (event.key === 'Escape') {\n    // This prevents the default browser behavior on `input[type=\"search\"]`\n    // from removing the query right away because we first want to close the\n    // panel.\n    event.preventDefault();\n\n    store.dispatch(event.key, null);\n\n    // Hitting the `Escape` key signals the end of a user interaction with the\n    // autocomplete. At this point, we should ignore any requests that are still\n    // pending and could reopen the panel once they resolve, because that would\n    // result in an unsolicited UI behavior.\n    store.pendingRequests.cancelAll();\n  } else if (event.key === 'Tab') {\n    store.dispatch('blur', null);\n\n    // Hitting the `Escape` key signals the end of a user interaction with the\n    // autocomplete. At this point, we should ignore any requests that are still\n    // pending and could reopen the panel once they resolve, because that would\n    // result in an unsolicited UI behavior.\n    store.pendingRequests.cancelAll();\n  } else if (event.key === 'Enter') {\n    // No active item, so we let the browser handle the native `onSubmit` form\n    // event.\n    if (\n      store.getState().activeItemId === null ||\n      store\n        .getState()\n        .collections.every((collection) => collection.items.length === 0)\n    ) {\n      // If requests are still pending when the panel closes, they could reopen\n      // the panel once they resolve.\n      // We want to prevent any subsequent query from reopening the panel\n      // because it would result in an unsolicited UI behavior.\n      if (!props.debug) {\n        store.pendingRequests.cancelAll();\n      }\n\n      return;\n    }\n\n    // This prevents the `onSubmit` event to be sent because an item is\n    // highlighted.\n    event.preventDefault();\n\n    const { item, itemInputValue, itemUrl, source } = getActiveItem(\n      store.getState()\n    )!;\n\n    if (event.metaKey || event.ctrlKey) {\n      if (itemUrl !== undefined) {\n        source.onSelect({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n        props.navigator.navigateNewTab({\n          itemUrl,\n          item,\n          state: store.getState(),\n        });\n      }\n    } else if (event.shiftKey) {\n      if (itemUrl !== undefined) {\n        source.onSelect({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n        props.navigator.navigateNewWindow({\n          itemUrl,\n          item,\n          state: store.getState(),\n        });\n      }\n    } else if (event.altKey) {\n      // Keep native browser behavior\n    } else {\n      if (itemUrl !== undefined) {\n        source.onSelect({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n        props.navigator.navigate({\n          itemUrl,\n          item,\n          state: store.getState(),\n        });\n\n        return;\n      }\n\n      onInput({\n        event,\n        nextState: { isOpen: false },\n        props,\n        query: itemInputValue,\n        refresh,\n        store,\n        ...setters,\n      }).then(() => {\n        source.onSelect({\n          event,\n          item,\n          itemInputValue,\n          itemUrl,\n          refresh,\n          source,\n          state: store.getState(),\n          ...setters,\n        });\n      });\n    }\n  }\n}\n","import { UserAgent, userAgents } from '@algolia/autocomplete-shared';\n\nimport {\n  AutocompleteEnvironment,\n  AutocompleteOptions,\n  AutocompleteOptionsWithMetadata,\n  AutocompletePlugin,\n  BaseItem,\n} from '.';\n\ntype AutocompleteMetadata = {\n  plugins: Array<{\n    name: string | undefined;\n    options: string[];\n  }>;\n  options: Record<string, string[]>;\n  ua: UserAgent[];\n};\n\ntype GetMetadataParams<TItem extends BaseItem, TData = unknown> = {\n  plugins: Array<AutocompletePlugin<TItem, TData>>;\n  options: AutocompleteOptionsWithMetadata<TItem>;\n};\n\nexport function getMetadata<TItem extends BaseItem, TData = unknown>({\n  plugins,\n  options,\n}: GetMetadataParams<TItem, TData>) {\n  const optionsKey = ((options.__autocomplete_metadata\n    ?.userAgents as UserAgent[]) || [])[0]?.segment;\n\n  const extraOptions = optionsKey\n    ? {\n        [optionsKey]: Object.keys(\n          (options.__autocomplete_metadata\n            ?.options as AutocompleteOptions<TItem>) || {}\n        ),\n      }\n    : {};\n\n  return {\n    plugins: plugins.map((plugin) => ({\n      name: plugin.name,\n      options: Object.keys(plugin.__autocomplete_pluginOptions || []),\n    })),\n    options: {\n      'autocomplete-core': Object.keys(options),\n      ...extraOptions,\n    },\n    ua: userAgents.concat(\n      (options.__autocomplete_metadata?.userAgents as any) || []\n    ),\n  };\n}\n\ntype InlineMetadataParams = {\n  metadata: AutocompleteMetadata;\n  environment: AutocompleteEnvironment;\n};\n\nexport function injectMetadata({\n  metadata,\n  environment,\n}: InlineMetadataParams) {\n  const isMetadataEnabled = environment.navigator?.userAgent?.includes(\n    'Algolia Crawler'\n  );\n\n  if (isMetadataEnabled) {\n    const metadataContainer = environment.document.createElement('meta');\n    const headRef = environment.document.querySelector('head');\n\n    metadataContainer.name = 'algolia:metadata';\n\n    setTimeout(() => {\n      metadataContainer.content = JSON.stringify(metadata);\n      headRef!.appendChild(metadataContainer);\n    }, 0);\n  }\n}\n","import { AutocompleteState, BaseItem } from './types';\nimport { getActiveItem } from './utils';\n\ninterface GetCompletionProps<TItem extends BaseItem> {\n  state: AutocompleteState<TItem>;\n}\n\nexport function getCompletion<TItem extends BaseItem>({\n  state,\n}: GetCompletionProps<TItem>): string | null {\n  if (state.isOpen === false || state.activeItemId === null) {\n    return null;\n  }\n\n  return getActiveItem(state)?.itemInputValue || null;\n}\n","import { getItemsCount, invariant } from '@algolia/autocomplete-shared';\n\nimport { getCompletion } from './getCompletion';\nimport { Reducer } from './types';\nimport { getNextActiveItemId } from './utils';\n\nexport const stateReducer: Reducer = (state, action) => {\n  switch (action.type) {\n    case 'setActiveItemId': {\n      return {\n        ...state,\n        activeItemId: action.payload,\n      };\n    }\n\n    case 'setQuery': {\n      return {\n        ...state,\n        query: action.payload,\n        completion: null,\n      };\n    }\n\n    case 'setCollections': {\n      return {\n        ...state,\n        collections: action.payload,\n      };\n    }\n\n    case 'setIsOpen': {\n      return {\n        ...state,\n        isOpen: action.payload,\n      };\n    }\n\n    case 'setStatus': {\n      return {\n        ...state,\n        status: action.payload,\n      };\n    }\n\n    case 'setContext': {\n      return {\n        ...state,\n        context: {\n          ...state.context,\n          ...action.payload,\n        },\n      };\n    }\n\n    case 'ArrowDown': {\n      const nextState = {\n        ...state,\n        activeItemId: action.payload.hasOwnProperty('nextActiveItemId')\n          ? action.payload.nextActiveItemId\n          : getNextActiveItemId(\n              1,\n              state.activeItemId,\n              getItemsCount(state),\n              action.props.defaultActiveItemId\n            ),\n      };\n\n      return {\n        ...nextState,\n        completion: getCompletion({ state: nextState }),\n      };\n    }\n\n    case 'ArrowUp': {\n      const nextState = {\n        ...state,\n        activeItemId: getNextActiveItemId(\n          -1,\n          state.activeItemId,\n          getItemsCount(state),\n          action.props.defaultActiveItemId\n        ),\n      };\n\n      return {\n        ...nextState,\n        completion: getCompletion({ state: nextState }),\n      };\n    }\n\n    case 'Escape': {\n      if (state.isOpen) {\n        return {\n          ...state,\n          activeItemId: null,\n          isOpen: false,\n          completion: null,\n        };\n      }\n\n      return {\n        ...state,\n        activeItemId: null,\n        query: '',\n        status: 'idle',\n        collections: [],\n      };\n    }\n\n    case 'submit': {\n      return {\n        ...state,\n        activeItemId: null,\n        isOpen: false,\n        status: 'idle',\n      };\n    }\n\n    case 'reset': {\n      return {\n        ...state,\n        activeItemId:\n          // Since we open the panel on reset when openOnFocus=true\n          // we need to restore the highlighted index to the defaultActiveItemId. (DocSearch use-case)\n\n          // Since we close the panel when openOnFocus=false\n          // we lose track of the highlighted index. (Query-suggestions use-case)\n          action.props.openOnFocus === true\n            ? action.props.defaultActiveItemId\n            : null,\n        status: 'idle',\n        query: '',\n      };\n    }\n\n    case 'focus': {\n      return {\n        ...state,\n        activeItemId: action.props.defaultActiveItemId,\n        isOpen:\n          (action.props.openOnFocus || Boolean(state.query)) &&\n          action.props.shouldPanelOpen({ state }),\n      };\n    }\n\n    case 'blur': {\n      if (action.props.debug) {\n        return state;\n      }\n\n      return {\n        ...state,\n        isOpen: false,\n        activeItemId: null,\n      };\n    }\n\n    case 'mousemove': {\n      return {\n        ...state,\n        activeItemId: action.payload,\n      };\n    }\n\n    case 'mouseleave': {\n      return {\n        ...state,\n        activeItemId: action.props.defaultActiveItemId,\n      };\n    }\n\n    default:\n      invariant(\n        false,\n        `The reducer action ${JSON.stringify(action.type)} is not supported.`\n      );\n\n      return state;\n  }\n};\n","import { checkOptions } from './checkOptions';\nimport { createStore } from './createStore';\nimport { getAutocompleteSetters } from './getAutocompleteSetters';\nimport { getDefaultProps } from './getDefaultProps';\nimport { getPropGetters } from './getPropGetters';\nimport { getMetadata, injectMetadata } from './metadata';\nimport { onInput } from './onInput';\nimport { stateReducer } from './stateReducer';\nimport {\n  AutocompleteApi,\n  AutocompleteOptions as AutocompleteCoreOptions,\n  BaseItem,\n  AutocompleteSubscribers,\n} from './types';\n\nexport interface AutocompleteOptionsWithMetadata<TItem extends BaseItem>\n  extends AutocompleteCoreOptions<TItem> {\n  /**\n   * @internal\n   */\n  __autocomplete_metadata?: Record<string, unknown>;\n}\n\nexport function createAutocomplete<\n  TItem extends BaseItem,\n  TEvent = Event,\n  TMouseEvent = MouseEvent,\n  TKeyboardEvent = KeyboardEvent\n>(\n  options: AutocompleteOptionsWithMetadata<TItem>\n): AutocompleteApi<TItem, TEvent, TMouseEvent, TKeyboardEvent> {\n  checkOptions(options);\n\n  const subscribers: AutocompleteSubscribers<TItem> = [];\n  const props = getDefaultProps(options, subscribers);\n  const store = createStore(stateReducer, props, onStoreStateChange);\n\n  const setters = getAutocompleteSetters({ store });\n  const propGetters = getPropGetters<\n    TItem,\n    TEvent,\n    TMouseEvent,\n    TKeyboardEvent\n  >({ props, refresh, store, navigator: props.navigator, ...setters });\n\n  function onStoreStateChange({ prevState, state }) {\n    props.onStateChange({\n      prevState,\n      state,\n      refresh,\n      navigator: props.navigator,\n      ...setters,\n    });\n  }\n\n  function refresh() {\n    return onInput({\n      event: new Event('input'),\n      nextState: { isOpen: store.getState().isOpen },\n      props,\n      navigator: props.navigator,\n      query: store.getState().query,\n      refresh,\n      store,\n      ...setters,\n    });\n  }\n\n  props.plugins.forEach((plugin) =>\n    plugin.subscribe?.({\n      ...setters,\n      navigator: props.navigator,\n      refresh,\n      onSelect(fn) {\n        subscribers.push({ onSelect: fn });\n      },\n      onActive(fn) {\n        subscribers.push({ onActive: fn });\n      },\n      onResolve(fn) {\n        subscribers.push({ onResolve: fn });\n      },\n    })\n  );\n\n  injectMetadata({\n    metadata: getMetadata({ plugins: props.plugins, options }),\n    environment: props.environment,\n  });\n\n  return {\n    refresh,\n    navigator: props.navigator,\n    ...propGetters,\n    ...setters,\n  };\n}\n","import {\n  AutocompleteState,\n  AutocompleteStore,\n  BaseItem,\n  InternalAutocompleteOptions,\n  Reducer,\n} from './types';\nimport { createCancelablePromiseList } from './utils';\n\ntype OnStoreStateChange<TItem extends BaseItem> = ({\n  prevState,\n  state,\n}: {\n  prevState: AutocompleteState<TItem>;\n  state: AutocompleteState<TItem>;\n}) => void;\n\nexport function createStore<TItem extends BaseItem>(\n  reducer: Reducer,\n  props: InternalAutocompleteOptions<TItem>,\n  onStoreStateChange: OnStoreStateChange<TItem>\n): AutocompleteStore<TItem> {\n  let state = props.initialState;\n\n  return {\n    getState() {\n      return state;\n    },\n    dispatch(action, payload) {\n      const prevState = { ...state };\n      state = reducer(state, {\n        type: action,\n        props,\n        payload,\n      });\n\n      onStoreStateChange({ state, prevState });\n    },\n    pendingRequests: createCancelablePromiseList(),\n  };\n}\n","import { CancelablePromise } from '.';\n\nexport type CancelablePromiseList<TValue> = {\n  /**\n   * Add a cancelable promise to the list.\n   *\n   * @param cancelablePromise The cancelable promise to add.\n   */\n  add(cancelablePromise: CancelablePromise<TValue>): CancelablePromise<TValue>;\n  /**\n   * Cancel all pending promises.\n   *\n   * Requests aren't actually stopped. All pending promises will settle, but\n   * attached handlers won't run.\n   */\n  cancelAll(): void;\n  /**\n   * Whether there are pending promises in the list.\n   */\n  isEmpty(): boolean;\n};\n\nexport function createCancelablePromiseList<\n  TValue\n>(): CancelablePromiseList<TValue> {\n  let list: Array<CancelablePromise<TValue>> = [];\n\n  return {\n    add(cancelablePromise) {\n      list.push(cancelablePromise);\n\n      return cancelablePromise.finally(() => {\n        list = list.filter((item) => item !== cancelablePromise);\n      });\n    },\n    cancelAll() {\n      list.forEach((promise) => promise.cancel());\n    },\n    isEmpty() {\n      return list.length === 0;\n    },\n  };\n}\n","import { flatten } from '@algolia/autocomplete-shared';\n\nimport {\n  AutocompleteApi,\n  AutocompleteCollection,\n  AutocompleteStore,\n  BaseItem,\n} from './types';\n\ninterface GetAutocompleteSettersOptions<TItem extends BaseItem> {\n  store: AutocompleteStore<TItem>;\n}\n\nexport function getAutocompleteSetters<TItem extends BaseItem>({\n  store,\n}: GetAutocompleteSettersOptions<TItem>) {\n  const setActiveItemId: AutocompleteApi<TItem>['setActiveItemId'] = (\n    value\n  ) => {\n    store.dispatch('setActiveItemId', value);\n  };\n\n  const setQuery: AutocompleteApi<TItem>['setQuery'] = (value) => {\n    store.dispatch('setQuery', value);\n  };\n\n  const setCollections: AutocompleteApi<TItem>['setCollections'] = (\n    rawValue\n  ) => {\n    let baseItemId = 0;\n    const value = rawValue.map<AutocompleteCollection<TItem>>((collection) => ({\n      ...collection,\n      // We flatten the stored items to support calling `getAlgoliaResults`\n      // from the source itself.\n      items: flatten(collection.items as any).map((item: any) => ({\n        ...item,\n        __autocomplete_id: baseItemId++,\n      })),\n    }));\n\n    store.dispatch('setCollections', value);\n  };\n\n  const setIsOpen: AutocompleteApi<TItem>['setIsOpen'] = (value) => {\n    store.dispatch('setIsOpen', value);\n  };\n\n  const setStatus: AutocompleteApi<TItem>['setStatus'] = (value) => {\n    store.dispatch('setStatus', value);\n  };\n\n  const setContext: AutocompleteApi<TItem>['setContext'] = (value) => {\n    store.dispatch('setContext', value);\n  };\n\n  return {\n    setActiveItemId,\n    setQuery,\n    setCollections,\n    setIsOpen,\n    setStatus,\n    setContext,\n  };\n}\n"],"names":["flatten","values","reduce","a","b","concat","autocompleteId","getItemsCount","state","collections","length","sum","collection","items","noop","userAgents","segment","version","createInternalCancelablePromise","promise","initialState","then","onfulfilled","onrejected","createCallback","catch","finally","onfinally","onCancelList","push","cancel","isCanceled","callbacks","forEach","callback","cancelable","onResult","fallback","arg","getNextActiveItemId","moveAmount","baseIndex","itemCount","defaultActiveItemId","numericIndex","getActiveItem","accumulatedCollectionsCount","collectionIndex","map","acc","collectionsCount","index","previousValue","nextValue","current","activeItemId","getCollectionFromActiveItemId","item","_ref","isOffsetFound","counter","previousItemsOffset","currentCollection","getRelativeActiveItemId","source","itemInputValue","getItemInputValue","itemUrl","getItemUrl","regex","getDefaultProps","props","pluginSubscribers","_props$id","environment","window","plugins","_objectSpread","debug","openOnFocus","placeholder","autoFocus","stallThreshold","shouldPanelOpen","reshape","_ref2","sources","id","query","completion","isOpen","status","context","onStateChange","params","_props$onStateChange","x","_x$onStateChange","onSubmit","_props$onSubmit","_x$onSubmit","onReset","_props$onReset","_x$onReset","getSources","Promise","all","_toConsumableArray","plugin","filter","Boolean","seenSourceIds","resolve","maybeSource","sourceId","includes","Error","JSON","stringify","defaultSource","onSelect","setIsOpen","onActive","onResolve","Object","keys","key","__default","normalizedSource","getNormalizedSources","nested","_x$onSelect","_x$onActive","_x$onResolve","navigator","navigate","_ref3","location","assign","navigateNewTab","_ref4","windowReference","open","focus","navigateNewWindow","_ref5","isDescription","execute","preResolve","itemsOrDescription","description","contextParameters","requesterId","apply","_state$context$key","__algoliaSearchParameters","requests","queries","transformResponse","packed","searchClient","container","find","_container$items","request","maybeDescription","responses","postResolve","store","matches","response","results","transform","rawResults","result","_hits","hits","hit","__autocomplete_indexName","__autocomplete_queryID","queryID","facetHits","_facetHits","facetHit","label","value","count","_highlightResult","highlighted","mapToAlgoliaResponse","getState","every","undefined","basePromiseId","latestResolvedId","latestResolvedValue","lastStalledId","runConcurrentSafePromise","currentPromiseId","onInput","event","_ref$nextState","nextState","refresh","setters","_objectWithoutProperties","_excluded","clearTimeout","setCollections","setQuery","setActiveItemId","setStatus","_nextState$isOpen","pendingRequests","add","setTimeout","getItems","originalSourcesBySourceId","sourcesBySourceId","_nextState$isOpen2","isPanelOpen","highlightedItem","getPropGetters","getAutocompleteId","instanceId","getEnvironmentProps","providedProps","inputElement","formElement","panelElement","onMouseDownOrTouchStart","isEmpty","target","some","contextNode","parent","child","contains","dispatch","cancelAll","onTouchStart","onMouseDown","onTouchMove","document","activeElement","blur","_excluded2","getRootProps","rest","role","getFormProps","action","noValidate","_providedProps$inputE","preventDefault","_providedProps$inputE2","_excluded3","getLabelProps","sourceIndex","_excluded5","htmlFor","getInputProps","_props$environment$na","onFocus","_ref2$maxLength","maxLength","_excluded4","activeItem","shouldFallbackKeyHint","userAgent","match","isSamsung","enterKeyHint","autoComplete","autoCorrect","autoCapitalize","spellCheck","type","onChange","currentTarget","slice","onKeyDown","triggerScrollIntoView","nodeItem","getElementById","scrollIntoViewIfNeeded","scrollIntoView","triggerOnActive","nextActiveItemId","metaKey","ctrlKey","shiftKey","altKey","onBlur","onClick","getPanelProps","onMouseLeave","getListProps","_excluded6","getItemProps","_excluded7","__autocomplete_id","onMouseMove","getMetadata","_","_options$__autocomple","_options$__autocomple2","_options$__autocomple3","options","optionsKey","__autocomplete_metadata","extraOptions","_defineProperty","name","__autocomplete_pluginOptions","ua","getCompletion","_getActiveItem","stateReducer","payload","hasOwnProperty","subscribers","reducer","onStoreStateChange","list","prevState","cancelablePromise","createStore","rawValue","baseItemId","setContext","getAutocompleteSetters","propGetters","Event","_plugin$subscribe","subscribe","fn","_environment$navigato","_environment$navigato2","metadata","metadataContainer","createElement","headRef","querySelector","content","appendChild","injectMetadata"],"mappings":"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"}