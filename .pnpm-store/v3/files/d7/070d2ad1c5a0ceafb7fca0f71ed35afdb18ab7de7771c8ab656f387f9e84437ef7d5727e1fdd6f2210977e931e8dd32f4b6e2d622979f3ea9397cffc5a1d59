{"version":3,"sources":["container/SequentialContainer/Deque.js","../../src/container/SequentialContainer/Deque.ts"],"names":["Object","defineProperty","exports","value","default","_Base","_interopRequireDefault","require","_RandomIterator","Math","_interopRequireWildcard","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","DequeIterator","RandomIterator","constructor","node","container","iteratorType","super","this","copy","_node","Deque","SequentialContainer","_bucketSize","_first","_curFirst","_last","_curLast","_bucketNum","_map","_length","length","size","TypeError","ceil","i","push","Array","needBucketNum","self","forEach","element","pushBack","_reAllocate","newMap","addBucketNum","_getElementIndex","pos","curNodeBucketIndex","curNodePointerIndex","index","floor","clear","begin","end","rBegin","rEnd","front","back","popBack","pushFront","popFront","getElementByPos","RangeError","setElementByPos","insert","num","arr","cut","eraseElementByPos","curBucket","curPointer","nextBucket","nextPointer","eraseElementByValue","eraseElementByIterator","iter","next","find","reverse","bucket","j","N","R","D","unique","pre","cur","sort","cmp","shrinkToFit","callback","Symbol","iterator","_default"],"mappings":"AAAA;;AAEAA,OAAOC,eAAeC,SAAS,KAAc;IAC3CC,OAAO;;;AAETD,QAAQE,eAAe;;ACLvB,IAAAC,QAAAC,uBAAAC,QAAA;;AAEA,IAAAC,kBAAAD,QAAA;;AAGA,IAAAE,OAAAC,wBAAAH,QAAA;;AAAqC,SAAAI,yBAAAC;IAAA,WAAAC,YAAA,YAAA,OAAA;IAAA,IAAAC,IAAA,IAAAD;IAAA,IAAAE,IAAA,IAAAF;IAAA,QAAAF,2BAAA,SAAAC;QAAA,OAAAA,IAAAG,IAAAD;AAAA,OAAAF;AAAA;;AAAA,SAAAF,wBAAAM,GAAAJ;IAAA,KAAAA,KAAAI,KAAAA,EAAAC,GAAA;QAAA,OAAAD;AAAA;IAAA,IAAAA,MAAA,eAAAA,MAAA,mBAAAA,MAAA,YAAA;QAAA,OAAA;YAAAZ,SAAAY;;AAAA;IAAA,IAAAE,IAAAP,yBAAAC;IAAA,IAAAM,KAAAA,EAAAC,IAAAH,IAAA;QAAA,OAAAE,EAAAE,IAAAJ;AAAA;IAAA,IAAAK,IAAA,CAAA;IAAA,IAAAC,IAAAtB,OAAAC,kBAAAD,OAAAuB;IAAA,KAAA,IAAAC,KAAAR,GAAA;QAAA,IAAAQ,MAAA,aAAAxB,OAAAyB,UAAAC,eAAAC,KAAAX,GAAAQ,IAAA;YAAA,IAAAI,IAAAN,IAAAtB,OAAAuB,yBAAAP,GAAAQ,KAAA;YAAA,IAAAI,MAAAA,EAAAR,OAAAQ,EAAAC,MAAA;gBAAA7B,OAAAC,eAAAoB,GAAAG,GAAAI;AAAA,mBAAA;gBAAAP,EAAAG,KAAAR,EAAAQ;AAAA;AAAA;AAAA;IAAAH,EAAAjB,UAAAY;IAAA,IAAAE,GAAA;QAAAA,EAAAW,IAAAb,GAAAK;AAAA;IAAA,OAAAA;AAAA;;AAAA,SAAAf,uBAAAU;IAAA,OAAAA,KAAAA,EAAAC,IAAAD,IAAA;QAAAZ,SAAAY;;AAAA;;AAErC,MAAMc,sBAAyBC,gBAAAA;IAE7BC,YAAYC,GAAcC,GAAqBC;QAC7CC,MAAMH,GAAME;QACZE,KAAKH,YAAYA;ADFjB;ICIFI;QACE,OAAO,IAAIR,cAAiBO,KAAKE,GAAOF,KAAKH,WAAWG,KAAKF;ADF7D;;;ACUJ,MAAMK,cAAiBC,MAAAA;IA6BrBT,YAAYE,IAA8B,IAAIQ,IAAe,KAAK;QAChEN;QA1BMC,KAAAM,IAAS;QAITN,KAAAO,IAAY;QAIZP,KAAAQ,IAAQ;QAIRR,KAAAS,IAAW;QAIXT,KAAAU,IAAa;QAQbV,KAAAW,IAAc;QAGpB,MAAMC,IAAO;YDXL,WCvC6Cf,EACvDgB,WAAM,UAAc,OAiDiBhB,EAjDCgB;YDwC5B,WCxCgDhB,EACrDiB,SAAI,UAAc,OAgDcjB,EA9CnCiB;YDuCQ,WCvCWjB,EAAUiB,SAAI,YACnC,OA6CqCjB,EA7CnBiB;YAAO,MACxB,IAAIC,UAAU;ADwCR,UCIQ;QACbf,KAAKK,IAAcA;QACnBL,KAAKU,IAAatC,KAAK4C,KAAKJ,GAASZ,KAAKK,MAAgB;QAC1D,KAAK,IAAIY,IAAI,GAAGA,IAAIjB,KAAKU,KAAcO,GAAG;YACxCjB,KAAKW,EAAKO,KAAK,IAAIC,MAAMnB,KAAKK;ADH5B;QCKJ,MAAMe,IAAgBhD,KAAK4C,KAAKJ,GAASZ,KAAKK;QAC9CL,KAAKM,IAASN,KAAKQ,KAASR,KAAKU,KAAc,MAAMU,KAAiB;QACtEpB,KAAKO,IAAYP,KAAKS,IAAYT,KAAKK,IAAcO,IAAUZ,KAAKK,KAAgB;QACpF,MAAMgB,IAAOrB;QACbH,EAAUyB,SAAQ,SAAUC;YAC1BF,EAAKG,SAASD;ADHZ;AACJ;ICSME,EAAYL;QAClB,MAAMM,IAAS;QACf,MAAMC,IAAeP,KAAiBpB,KAAKU,KAAc,KAAK;QAC9D,KAAK,IAAIO,IAAI,GAAGA,IAAIU,KAAgBV,GAAG;YACrCS,EAAOT,KAAK,IAAIE,MAAMnB,KAAKK;ADHzB;QCKJ,KAAK,IAAIY,IAAIjB,KAAKM,GAAQW,IAAIjB,KAAKU,KAAcO,GAAG;YAClDS,EAAOA,EAAOb,UAAUb,KAAKW,EAAKM;ADHhC;QCKJ,KAAK,IAAIA,IAAI,GAAGA,IAAIjB,KAAKQ,KAASS,GAAG;YACnCS,EAAOA,EAAOb,UAAUb,KAAKW,EAAKM;ADHhC;QCKJS,EAAOA,EAAOb,UAAU,KAAIb,KAAKW,EAAKX,KAAKQ;QAC3CR,KAAKM,IAASqB;QACd3B,KAAKQ,IAAQkB,EAAOb,SAAS;QAC7B,KAAK,IAAII,IAAI,GAAGA,IAAIU,KAAgBV,GAAG;YACrCS,EAAOA,EAAOb,UAAU,IAAIM,MAAMnB,KAAKK;ADHrC;QCKJL,KAAKW,IAAOe;QACZ1B,KAAKU,IAAagB,EAAOb;ADHzB;ICUMe,EAAiBC;QACvB,IAAIC,GAAoBC;QACxB,MAAMC,IAAQhC,KAAKO,IAAYsB;QAC/BC,IAAqB9B,KAAKM,IAASlC,KAAK6D,MAAMD,IAAQhC,KAAKK;QAC3D,IAAIyB,KAAsB9B,KAAKU,GAAY;YACzCoB,KAAsB9B,KAAKU;ADHzB;QCKJqB,KAAuBC,IAAQ,KAAKhC,KAAKK,IAAc;QACvD,IAAI0B,IAAsB,GAAG;YAC3BA,IAAsB/B,KAAKK,IAAc;ADHvC;QCKJ,OAAO;YAAEyB;YAAoBC;;ADH7B;ICKFG;QACElC,KAAKW,IAAO,EAAC,IAAIQ,MAAMnB,KAAKK;QAC5BL,KAAKU,IAAa;QAClBV,KAAKM,IAASN,KAAKQ,IAAQR,KAAKY,IAAU;QAC1CZ,KAAKO,IAAYP,KAAKS,IAAWT,KAAKK,KAAe;ADHrD;ICKF8B;QACE,OAAO,IAAI1C,cAAiB,GAAGO;ADH/B;ICKFoC;QACE,OAAO,IAAI3C,cAAiBO,KAAKY,GAASZ;ADH1C;ICKFqC;QACE,OAAO,IAAI5C,cAAiBO,KAAKY,IAAU,GAAGZ,MAAI;ADHlD;ICKFsC;QACE,OAAO,IAAI7C,eAAkB,GAAGO,MAAI;ADHpC;ICKFuC;QACE,IAAIvC,KAAKY,MAAY,GAAG;QACxB,OAAOZ,KAAKW,EAAKX,KAAKM,GAAQN,KAAKO;ADFnC;ICIFiC;QACE,IAAIxC,KAAKY,MAAY,GAAG;QACxB,OAAOZ,KAAKW,EAAKX,KAAKQ,GAAOR,KAAKS;ADDlC;ICGFe,SAASD;QACP,IAAIvB,KAAKY,GAAS;YAChB,IAAIZ,KAAKS,IAAWT,KAAKK,IAAc,GAAG;gBACxCL,KAAKS,KAAY;ADDb,mBCEC,IAAIT,KAAKQ,IAAQR,KAAKU,IAAa,GAAG;gBAC3CV,KAAKQ,KAAS;gBACdR,KAAKS,IAAW;ADAZ,mBCCC;gBACLT,KAAKQ,IAAQ;gBACbR,KAAKS,IAAW;ADCZ;YCCN,IACET,KAAKQ,MAAUR,KAAKM,KACpBN,KAAKS,MAAaT,KAAKO,GACvBP,KAAKyB;ADAL;QCEJzB,KAAKY,KAAW;QAChBZ,KAAKW,EAAKX,KAAKQ,GAAOR,KAAKS,KAAYc;QACvC,OAAOvB,KAAKY;ADAZ;ICEF6B;QACE,IAAIzC,KAAKY,MAAY,GAAG;QACxB,MAAM9C,IAAQkC,KAAKW,EAAKX,KAAKQ,GAAOR,KAAKS;QACzC,IAAIT,KAAKY,MAAY,GAAG;YACtB,IAAIZ,KAAKS,IAAW,GAAG;gBACrBT,KAAKS,KAAY;ADCb,mBCAC,IAAIT,KAAKQ,IAAQ,GAAG;gBACzBR,KAAKQ,KAAS;gBACdR,KAAKS,IAAWT,KAAKK,IAAc;ADE/B,mBCDC;gBACLL,KAAKQ,IAAQR,KAAKU,IAAa;gBAC/BV,KAAKS,IAAWT,KAAKK,IAAc;ADG/B;AACJ;QCDJL,KAAKY,KAAW;QAChB,OAAO9C;ADGP;ICIF4E,UAAUnB;QACR,IAAIvB,KAAKY,GAAS;YAChB,IAAIZ,KAAKO,IAAY,GAAG;gBACtBP,KAAKO,KAAa;ADGd,mBCFC,IAAIP,KAAKM,IAAS,GAAG;gBAC1BN,KAAKM,KAAU;gBACfN,KAAKO,IAAYP,KAAKK,IAAc;ADIhC,mBCHC;gBACLL,KAAKM,IAASN,KAAKU,IAAa;gBAChCV,KAAKO,IAAYP,KAAKK,IAAc;ADKhC;YCHN,IACEL,KAAKM,MAAWN,KAAKQ,KACrBR,KAAKO,MAAcP,KAAKS,GACxBT,KAAKyB;ADIL;QCFJzB,KAAKY,KAAW;QAChBZ,KAAKW,EAAKX,KAAKM,GAAQN,KAAKO,KAAagB;QACzC,OAAOvB,KAAKY;ADIZ;ICEF+B;QACE,IAAI3C,KAAKY,MAAY,GAAG;QACxB,MAAM9C,IAAQkC,KAAKW,EAAKX,KAAKM,GAAQN,KAAKO;QAC1C,IAAIP,KAAKY,MAAY,GAAG;YACtB,IAAIZ,KAAKO,IAAYP,KAAKK,IAAc,GAAG;gBACzCL,KAAKO,KAAa;ADKd,mBCJC,IAAIP,KAAKM,IAASN,KAAKU,IAAa,GAAG;gBAC5CV,KAAKM,KAAU;gBACfN,KAAKO,IAAY;ADMb,mBCLC;gBACLP,KAAKM,IAAS;gBACdN,KAAKO,IAAY;ADOb;AACJ;QCLJP,KAAKY,KAAW;QAChB,OAAO9C;ADOP;ICLF8E,gBAAgBf;QDOV,ICNsBA,IAAG,KAAHA,IAAQ7B,KAAKY,IAAO,GAvNvB;YAAE,MAE7B,IAAIiC;AD6NI;QCPJ,OAAMf,oBACJA,GAAkBC,qBAClBA,KACE/B,KAAK4B,EAAiBC;QAC1B,OAAO7B,KAAKW,EAAKmB,GAAoBC;ADMrC;ICJFe,gBAAgBjB,GAAaN;QDMvB,ICLsBM,IAAG,KAAHA,IAAQ7B,KAAKY,IAAO,GA/NvB;YAAE,MAE7B,IAAIiC;ADoOI;QCNJ,OAAMf,oBACJA,GAAkBC,qBAClBA,KACE/B,KAAK4B,EAAiBC;QAC1B7B,KAAKW,EAAKmB,GAAoBC,KAAuBR;ADKrD;ICHFwB,OAAOlB,GAAaN,GAAYyB,IAAM;QACpC,MAAMnC,IAASb,KAAKY;QDKhB,ICJsBiB,IAAG,KAAHA,IAAQhB,GAxOX;YAAE,MAE7B,IAAIgC;AD4OI;QCLJ,IAAIhB,MAAQ,GAAG;YACb,OAAOmB,KAAOhD,KAAK0C,UAAUnB;ADQ3B,eCPG,IAAIM,MAAQ7B,KAAKY,GAAS;YAC/B,OAAOoC,KAAOhD,KAAKwB,SAASD;ADU1B,eCTG;YACL,MAAM0B,IAAW;YACjB,KAAK,IAAIhC,IAAIY,GAAKZ,IAAIjB,KAAKY,KAAWK,GAAG;gBACvCgC,EAAI/B,KAAKlB,KAAK4C,gBAAgB3B;ADW1B;YCTNjB,KAAKkD,IAAIrB,IAAM;YACf,KAAK,IAAIZ,IAAI,GAAGA,IAAI+B,KAAO/B,GAAGjB,KAAKwB,SAASD;YAC5C,KAAK,IAAIN,IAAI,GAAGA,IAAIgC,EAAIpC,UAAUI,GAAGjB,KAAKwB,SAASyB,EAAIhC;ADarD;QCXJ,OAAOjB,KAAKY;ADaZ;ICJFsC,IAAIrB;QACF,IAAIA,IAAM,GAAG;YACX7B,KAAKkC;YACL,OAAO;ADaL;QCXJ,OAAMJ,oBACJA,GAAkBC,qBAClBA,KACE/B,KAAK4B,EAAiBC;QAC1B7B,KAAKQ,IAAQsB;QACb9B,KAAKS,IAAWsB;QAChB/B,KAAKY,IAAUiB,IAAM;QACrB,OAAO7B,KAAKY;ADUZ;ICRFuC,kBAAkBtB;QDUZ,ICTsBA,IAAG,KAAHA,IAAQ7B,KAAKY,IAAO,GA9QvB;YAAE,MAE7B,IAAIiC;ADuRI;QCVJ,IAAIhB,MAAQ,GAAG7B,KAAK2C,iBACf,IAAId,MAAQ7B,KAAKY,IAAU,GAAGZ,KAAKyC,gBACnC;YACH,MAAM5B,IAASb,KAAKY,IAAU;YAC9B,KACEkB,oBAAoBsB,GACpBrB,qBAAqBsB,KACnBrD,KAAK4B,EAAiBC;YAC1B,KAAK,IAAIZ,IAAIY,GAAKZ,IAAIJ,KAAUI,GAAG;gBACjC,OACEa,oBAAoBwB,GACpBvB,qBAAqBwB,KACnBvD,KAAK4B,EAAiBC,IAAM;gBAChC7B,KAAKW,EAAKyC,GAAWC,KAAcrD,KAAKW,EAAK2C,GAAYC;gBACzDH,IAAYE;gBACZD,IAAaE;ADQT;YCNNvD,KAAKyC;ADQH;QCNJ,OAAOzC,KAAKY;ADQZ;ICNF4C,oBAAoB1F;QAClB,MAAM+C,IAASb,KAAKY;QACpB,IAAIC,MAAW,GAAG,OAAO;QACzB,IAAII,IAAI;QACR,IAAIe,IAAQ;QACZ,OAAOf,IAAIJ,GAAQ;YACjB,MAAMU,IAAUvB,KAAK4C,gBAAgB3B;YACrC,IAAIM,MAAYzD,GAAO;gBACrBkC,KAAK8C,gBAAgBd,GAAOT;gBAC5BS,KAAS;ADSL;YCPNf,KAAK;ADSH;QCPJjB,KAAKkD,IAAIlB,IAAQ;QACjB,OAAOhC,KAAKY;ADSZ;ICPF6C,uBAAuBC;QACrB,MAAMxD,IAAQwD,EAAKxD;QACnBF,KAAKmD,kBAAkBjD;QACvBwD,IAAOA,EAAKC;QACZ,OAAOD;ADSP;ICPFE,KAAKrC;QACH,KAAK,IAAIN,IAAI,GAAGA,IAAIjB,KAAKY,KAAWK,GAAG;YACrC,IAAIjB,KAAK4C,gBAAgB3B,OAAOM,GAAS;gBACvC,OAAO,IAAI9B,cAAiBwB,GAAGjB;ADS3B;AACJ;QCPJ,OAAOA,KAAKoC;ADSZ;ICPFyB;QACE7D,KAAKW,EAAKkD,UAAUvC,SAAQ,SAAUwC;YACpCA,EAAOD;ADSL;QCPJ,OAAME,GAAEzD,GAAM0D,GAAExD,GAAKyD,GAAE1D,GAAS2D,GAAEzD,KAAaT;QAC/CA,KAAKM,IAASN,KAAKU,IAAaF,IAAQ;QACxCR,KAAKQ,IAAQR,KAAKU,IAAaJ,IAAS;QACxCN,KAAKO,IAAYP,KAAKK,IAAcI,IAAW;QAC/CT,KAAKS,IAAWT,KAAKK,IAAcE,IAAY;QAC/C,OAAOP;ADSP;ICPFmE;QACE,IAAInE,KAAKY,KAAW,GAAG;YACrB,OAAOZ,KAAKY;ADSV;QCPJ,IAAIoB,IAAQ;QACZ,IAAIoC,IAAMpE,KAAK4C,gBAAgB;QAC/B,KAAK,IAAI3B,IAAI,GAAGA,IAAIjB,KAAKY,KAAWK,GAAG;YACrC,MAAMoD,IAAMrE,KAAK4C,gBAAgB3B;YACjC,IAAIoD,MAAQD,GAAK;gBACfA,IAAMC;gBACNrE,KAAK8C,gBAAgBd,KAASqC;ADS1B;AACJ;QCPJrE,KAAKkD,IAAIlB,IAAQ;QACjB,OAAOhC,KAAKY;ADSZ;ICPF0D,KAAKC;QACH,MAAMtB,IAAW;QACjB,KAAK,IAAIhC,IAAI,GAAGA,IAAIjB,KAAKY,KAAWK,GAAG;YACrCgC,EAAI/B,KAAKlB,KAAK4C,gBAAgB3B;ADS5B;QCPJgC,EAAIqB,KAAKC;QACT,KAAK,IAAItD,IAAI,GAAGA,IAAIjB,KAAKY,KAAWK,GAAG;YACrCjB,KAAK8C,gBAAgB7B,GAAGgC,EAAIhC;ADS1B;QCPJ,OAAOjB;ADSP;ICJFwE;QACE,IAAIxE,KAAKY,MAAY,GAAG;QACxB,MAAMc,IAAS;QACf,IAAI1B,KAAKM,MAAWN,KAAKQ,GAAO,aAC3B,IAAIR,KAAKM,IAASN,KAAKQ,GAAO;YACjC,KAAK,IAAIS,IAAIjB,KAAKM,GAAQW,KAAKjB,KAAKQ,KAASS,GAAG;gBAC9CS,EAAOR,KAAKlB,KAAKW,EAAKM;ADWlB;AACJ,eCVG;YACL,KAAK,IAAIA,IAAIjB,KAAKM,GAAQW,IAAIjB,KAAKU,KAAcO,GAAG;gBAClDS,EAAOR,KAAKlB,KAAKW,EAAKM;ADYlB;YCVN,KAAK,IAAIA,IAAI,GAAGA,KAAKjB,KAAKQ,KAASS,GAAG;gBACpCS,EAAOR,KAAKlB,KAAKW,EAAKM;ADYlB;AACJ;QCVJjB,KAAKM,IAAS;QACdN,KAAKQ,IAAQkB,EAAOb,SAAS;QAC7Bb,KAAKW,IAAOe;ADYZ;ICVFJ,QAAQmD;QACN,KAAK,IAAIxD,IAAI,GAAGA,IAAIjB,KAAKY,KAAWK,GAAG;YACrCwD,EAASzE,KAAK4C,gBAAgB3B,IAAIA,GAAGjB;ADYnC;AACJ;ICVF,GAAG0E,OAAOC;QACR,KAAK,IAAI1D,IAAI,GAAGA,IAAIjB,KAAKY,KAAWK,GAAG;kBAC/BjB,KAAK4C,gBAAgB3B;ADYzB;AACJ;;;ACVH,IAAA2D,WAEczE;;AAAKtC,QAAAE,UAAA6G","file":"Deque.js","sourcesContent":["import SequentialContainer from './Base';\nimport { RandomIterator } from \"./Base/RandomIterator\";\nimport $checkWithinAccessParams from \"../../utils/checkParams.macro\";\nimport $getContainerSize from \"../../utils/getContainerSize.macro\";\nimport * as Math from \"../../utils/math\";\nclass DequeIterator extends RandomIterator {\n    constructor(node, container, iteratorType) {\n        super(node, iteratorType);\n        this.container = container;\n    }\n    copy() {\n        return new DequeIterator(this._node, this.container, this.iteratorType);\n    }\n}\nclass Deque extends SequentialContainer {\n    constructor(container = [], _bucketSize = (1 << 12)) {\n        super();\n        /**\n         * @internal\n         */\n        this._first = 0;\n        /**\n         * @internal\n         */\n        this._curFirst = 0;\n        /**\n         * @internal\n         */\n        this._last = 0;\n        /**\n         * @internal\n         */\n        this._curLast = 0;\n        /**\n         * @internal\n         */\n        this._bucketNum = 0;\n        /**\n         * @internal\n         */\n        this._map = [];\n        const _length = (() => {\n            if (typeof container.length === \"number\")\n                return container.length;\n            if (typeof container.size === \"number\")\n                return container.size;\n            if (typeof container.size === \"function\")\n                return container.size();\n            throw new TypeError(\"Cannot get the length or size of the container\");\n        })();\n        this._bucketSize = _bucketSize;\n        this._bucketNum = Math.ceil(_length, this._bucketSize) || 1;\n        for (let i = 0; i < this._bucketNum; ++i) {\n            this._map.push(new Array(this._bucketSize));\n        }\n        const needBucketNum = Math.ceil(_length, this._bucketSize);\n        this._first = this._last = (this._bucketNum >> 1) - (needBucketNum >> 1);\n        this._curFirst = this._curLast = (this._bucketSize - _length % this._bucketSize) >> 1;\n        const self = this;\n        container.forEach(function (element) {\n            self.pushBack(element);\n        });\n    }\n    /**\n     * @description Growth the Deque.\n     * @internal\n     */\n    _reAllocate(needBucketNum) {\n        const newMap = [];\n        const addBucketNum = needBucketNum || this._bucketNum >> 1 || 1;\n        for (let i = 0; i < addBucketNum; ++i) {\n            newMap[i] = new Array(this._bucketSize);\n        }\n        for (let i = this._first; i < this._bucketNum; ++i) {\n            newMap[newMap.length] = this._map[i];\n        }\n        for (let i = 0; i < this._last; ++i) {\n            newMap[newMap.length] = this._map[i];\n        }\n        newMap[newMap.length] = [...this._map[this._last]];\n        this._first = addBucketNum;\n        this._last = newMap.length - 1;\n        for (let i = 0; i < addBucketNum; ++i) {\n            newMap[newMap.length] = new Array(this._bucketSize);\n        }\n        this._map = newMap;\n        this._bucketNum = newMap.length;\n    }\n    /**\n     * @description Get the bucket position of the element and the pointer position by index.\n     * @param pos - The element's index.\n     * @internal\n     */\n    _getElementIndex(pos) {\n        let curNodeBucketIndex, curNodePointerIndex;\n        const index = this._curFirst + pos;\n        curNodeBucketIndex = this._first + Math.floor(index / this._bucketSize);\n        if (curNodeBucketIndex >= this._bucketNum) {\n            curNodeBucketIndex -= this._bucketNum;\n        }\n        curNodePointerIndex = (index + 1) % this._bucketSize - 1;\n        if (curNodePointerIndex < 0) {\n            curNodePointerIndex = this._bucketSize - 1;\n        }\n        return { curNodeBucketIndex, curNodePointerIndex };\n    }\n    clear() {\n        this._map = [new Array(this._bucketSize)];\n        this._bucketNum = 1;\n        this._first = this._last = this._length = 0;\n        this._curFirst = this._curLast = this._bucketSize >> 1;\n    }\n    begin() {\n        return new DequeIterator(0, this);\n    }\n    end() {\n        return new DequeIterator(this._length, this);\n    }\n    rBegin() {\n        return new DequeIterator(this._length - 1, this, 1 /* IteratorType.REVERSE */);\n    }\n    rEnd() {\n        return new DequeIterator(-1, this, 1 /* IteratorType.REVERSE */);\n    }\n    front() {\n        if (this._length === 0)\n            return;\n        return this._map[this._first][this._curFirst];\n    }\n    back() {\n        if (this._length === 0)\n            return;\n        return this._map[this._last][this._curLast];\n    }\n    pushBack(element) {\n        if (this._length) {\n            if (this._curLast < this._bucketSize - 1) {\n                this._curLast += 1;\n            }\n            else if (this._last < this._bucketNum - 1) {\n                this._last += 1;\n                this._curLast = 0;\n            }\n            else {\n                this._last = 0;\n                this._curLast = 0;\n            }\n            if (this._last === this._first &&\n                this._curLast === this._curFirst)\n                this._reAllocate();\n        }\n        this._length += 1;\n        this._map[this._last][this._curLast] = element;\n        return this._length;\n    }\n    popBack() {\n        if (this._length === 0)\n            return;\n        const value = this._map[this._last][this._curLast];\n        if (this._length !== 1) {\n            if (this._curLast > 0) {\n                this._curLast -= 1;\n            }\n            else if (this._last > 0) {\n                this._last -= 1;\n                this._curLast = this._bucketSize - 1;\n            }\n            else {\n                this._last = this._bucketNum - 1;\n                this._curLast = this._bucketSize - 1;\n            }\n        }\n        this._length -= 1;\n        return value;\n    }\n    /**\n     * @description Push the element to the front.\n     * @param element - The element you want to push.\n     * @returns The size of queue after pushing.\n     */\n    pushFront(element) {\n        if (this._length) {\n            if (this._curFirst > 0) {\n                this._curFirst -= 1;\n            }\n            else if (this._first > 0) {\n                this._first -= 1;\n                this._curFirst = this._bucketSize - 1;\n            }\n            else {\n                this._first = this._bucketNum - 1;\n                this._curFirst = this._bucketSize - 1;\n            }\n            if (this._first === this._last &&\n                this._curFirst === this._curLast)\n                this._reAllocate();\n        }\n        this._length += 1;\n        this._map[this._first][this._curFirst] = element;\n        return this._length;\n    }\n    /**\n     * @description Remove the _first element.\n     * @returns The element you popped.\n     */\n    popFront() {\n        if (this._length === 0)\n            return;\n        const value = this._map[this._first][this._curFirst];\n        if (this._length !== 1) {\n            if (this._curFirst < this._bucketSize - 1) {\n                this._curFirst += 1;\n            }\n            else if (this._first < this._bucketNum - 1) {\n                this._first += 1;\n                this._curFirst = 0;\n            }\n            else {\n                this._first = 0;\n                this._curFirst = 0;\n            }\n        }\n        this._length -= 1;\n        return value;\n    }\n    getElementByPos(pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        const { curNodeBucketIndex, curNodePointerIndex } = this._getElementIndex(pos);\n        return this._map[curNodeBucketIndex][curNodePointerIndex];\n    }\n    setElementByPos(pos, element) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        const { curNodeBucketIndex, curNodePointerIndex } = this._getElementIndex(pos);\n        this._map[curNodeBucketIndex][curNodePointerIndex] = element;\n    }\n    insert(pos, element, num = 1) {\n        const length = this._length;\n        if (pos < 0 || pos > length) {\n            throw new RangeError();\n        }\n        if (pos === 0) {\n            while (num--)\n                this.pushFront(element);\n        }\n        else if (pos === this._length) {\n            while (num--)\n                this.pushBack(element);\n        }\n        else {\n            const arr = [];\n            for (let i = pos; i < this._length; ++i) {\n                arr.push(this.getElementByPos(i));\n            }\n            this.cut(pos - 1);\n            for (let i = 0; i < num; ++i)\n                this.pushBack(element);\n            for (let i = 0; i < arr.length; ++i)\n                this.pushBack(arr[i]);\n        }\n        return this._length;\n    }\n    /**\n     * @description Remove all elements after the specified position (excluding the specified position).\n     * @param pos - The previous position of the first removed element.\n     * @returns The size of the container after cutting.\n     * @example\n     * deque.cut(1); // Then deque's size will be 2. deque -> [0, 1]\n     */\n    cut(pos) {\n        if (pos < 0) {\n            this.clear();\n            return 0;\n        }\n        const { curNodeBucketIndex, curNodePointerIndex } = this._getElementIndex(pos);\n        this._last = curNodeBucketIndex;\n        this._curLast = curNodePointerIndex;\n        this._length = pos + 1;\n        return this._length;\n    }\n    eraseElementByPos(pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        if (pos === 0)\n            this.popFront();\n        else if (pos === this._length - 1)\n            this.popBack();\n        else {\n            const length = this._length - 1;\n            let { curNodeBucketIndex: curBucket, curNodePointerIndex: curPointer } = this._getElementIndex(pos);\n            for (let i = pos; i < length; ++i) {\n                const { curNodeBucketIndex: nextBucket, curNodePointerIndex: nextPointer } = this._getElementIndex(pos + 1);\n                this._map[curBucket][curPointer] = this._map[nextBucket][nextPointer];\n                curBucket = nextBucket;\n                curPointer = nextPointer;\n            }\n            this.popBack();\n        }\n        return this._length;\n    }\n    eraseElementByValue(value) {\n        const length = this._length;\n        if (length === 0)\n            return 0;\n        let i = 0;\n        let index = 0;\n        while (i < length) {\n            const element = this.getElementByPos(i);\n            if (element !== value) {\n                this.setElementByPos(index, element);\n                index += 1;\n            }\n            i += 1;\n        }\n        this.cut(index - 1);\n        return this._length;\n    }\n    eraseElementByIterator(iter) {\n        const _node = iter._node;\n        this.eraseElementByPos(_node);\n        iter = iter.next();\n        return iter;\n    }\n    find(element) {\n        for (let i = 0; i < this._length; ++i) {\n            if (this.getElementByPos(i) === element) {\n                return new DequeIterator(i, this);\n            }\n        }\n        return this.end();\n    }\n    reverse() {\n        this._map.reverse().forEach(function (bucket) {\n            bucket.reverse();\n        });\n        const { _first, _last, _curFirst, _curLast } = this;\n        this._first = this._bucketNum - _last - 1;\n        this._last = this._bucketNum - _first - 1;\n        this._curFirst = this._bucketSize - _curLast - 1;\n        this._curLast = this._bucketSize - _curFirst - 1;\n        return this;\n    }\n    unique() {\n        if (this._length <= 1) {\n            return this._length;\n        }\n        let index = 1;\n        let pre = this.getElementByPos(0);\n        for (let i = 1; i < this._length; ++i) {\n            const cur = this.getElementByPos(i);\n            if (cur !== pre) {\n                pre = cur;\n                this.setElementByPos(index++, cur);\n            }\n        }\n        this.cut(index - 1);\n        return this._length;\n    }\n    sort(cmp) {\n        const arr = [];\n        for (let i = 0; i < this._length; ++i) {\n            arr.push(this.getElementByPos(i));\n        }\n        arr.sort(cmp);\n        for (let i = 0; i < this._length; ++i) {\n            this.setElementByPos(i, arr[i]);\n        }\n        return this;\n    }\n    /**\n     * @description Remove as much useless space as possible.\n     */\n    shrinkToFit() {\n        if (this._length === 0)\n            return;\n        const newMap = [];\n        if (this._first === this._last)\n            return;\n        else if (this._first < this._last) {\n            for (let i = this._first; i <= this._last; ++i) {\n                newMap.push(this._map[i]);\n            }\n        }\n        else {\n            for (let i = this._first; i < this._bucketNum; ++i) {\n                newMap.push(this._map[i]);\n            }\n            for (let i = 0; i <= this._last; ++i) {\n                newMap.push(this._map[i]);\n            }\n        }\n        this._first = 0;\n        this._last = newMap.length - 1;\n        this._map = newMap;\n    }\n    forEach(callback) {\n        for (let i = 0; i < this._length; ++i) {\n            callback(this.getElementByPos(i), i, this);\n        }\n    }\n    *[Symbol.iterator]() {\n        for (let i = 0; i < this._length; ++i) {\n            yield this.getElementByPos(i);\n        }\n    }\n}\nexport default Deque;\n","import SequentialContainer from './Base';\nimport { IteratorType, initContainer } from '@/container/ContainerBase';\nimport { RandomIterator } from '@/container/SequentialContainer/Base/RandomIterator';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport $getContainerSize from '@/utils/getContainerSize.macro';\nimport * as Math from '@/utils/math';\n\nclass DequeIterator<T> extends RandomIterator<T> {\n  readonly container: Deque<T>;\n  constructor(node: number, container: Deque<T>, iteratorType?: IteratorType) {\n    super(node, iteratorType);\n    this.container = container;\n  }\n  copy() {\n    return new DequeIterator<T>(this._node, this.container, this.iteratorType);\n  }\n  // @ts-ignore\n  equals(iter: DequeIterator<T>): boolean;\n}\n\nexport type { DequeIterator };\n\nclass Deque<T> extends SequentialContainer<T> {\n  /**\n   * @internal\n   */\n  private _first = 0;\n  /**\n   * @internal\n   */\n  private _curFirst = 0;\n  /**\n   * @internal\n   */\n  private _last = 0;\n  /**\n   * @internal\n   */\n  private _curLast = 0;\n  /**\n   * @internal\n   */\n  private _bucketNum = 0;\n  /**\n   * @internal\n   */\n  private readonly _bucketSize: number;\n  /**\n   * @internal\n   */\n  private _map: T[][] = [];\n  constructor(container: initContainer<T> = [], _bucketSize = (1 << 12)) {\n    super();\n    const _length = $getContainerSize!(container);\n    this._bucketSize = _bucketSize;\n    this._bucketNum = Math.ceil(_length, this._bucketSize) || 1;\n    for (let i = 0; i < this._bucketNum; ++i) {\n      this._map.push(new Array(this._bucketSize));\n    }\n    const needBucketNum = Math.ceil(_length, this._bucketSize);\n    this._first = this._last = (this._bucketNum >> 1) - (needBucketNum >> 1);\n    this._curFirst = this._curLast = (this._bucketSize - _length % this._bucketSize) >> 1;\n    const self = this;\n    container.forEach(function (element) {\n      self.pushBack(element);\n    });\n  }\n  /**\n   * @description Growth the Deque.\n   * @internal\n   */\n  private _reAllocate(needBucketNum?: number) {\n    const newMap = [];\n    const addBucketNum = needBucketNum || this._bucketNum >> 1 || 1;\n    for (let i = 0; i < addBucketNum; ++i) {\n      newMap[i] = new Array(this._bucketSize);\n    }\n    for (let i = this._first; i < this._bucketNum; ++i) {\n      newMap[newMap.length] = this._map[i];\n    }\n    for (let i = 0; i < this._last; ++i) {\n      newMap[newMap.length] = this._map[i];\n    }\n    newMap[newMap.length] = [...this._map[this._last]];\n    this._first = addBucketNum;\n    this._last = newMap.length - 1;\n    for (let i = 0; i < addBucketNum; ++i) {\n      newMap[newMap.length] = new Array(this._bucketSize);\n    }\n    this._map = newMap;\n    this._bucketNum = newMap.length;\n  }\n  /**\n   * @description Get the bucket position of the element and the pointer position by index.\n   * @param pos - The element's index.\n   * @internal\n   */\n  private _getElementIndex(pos: number) {\n    let curNodeBucketIndex, curNodePointerIndex;\n    const index = this._curFirst + pos;\n    curNodeBucketIndex = this._first + Math.floor(index / this._bucketSize);\n    if (curNodeBucketIndex >= this._bucketNum) {\n      curNodeBucketIndex -= this._bucketNum;\n    }\n    curNodePointerIndex = (index + 1) % this._bucketSize - 1;\n    if (curNodePointerIndex < 0) {\n      curNodePointerIndex = this._bucketSize - 1;\n    }\n    return { curNodeBucketIndex, curNodePointerIndex };\n  }\n  clear() {\n    this._map = [new Array(this._bucketSize)];\n    this._bucketNum = 1;\n    this._first = this._last = this._length = 0;\n    this._curFirst = this._curLast = this._bucketSize >> 1;\n  }\n  begin() {\n    return new DequeIterator<T>(0, this);\n  }\n  end() {\n    return new DequeIterator<T>(this._length, this);\n  }\n  rBegin() {\n    return new DequeIterator<T>(this._length - 1, this, IteratorType.REVERSE);\n  }\n  rEnd() {\n    return new DequeIterator<T>(-1, this, IteratorType.REVERSE);\n  }\n  front(): T | undefined {\n    if (this._length === 0) return;\n    return this._map[this._first][this._curFirst];\n  }\n  back(): T | undefined {\n    if (this._length === 0) return;\n    return this._map[this._last][this._curLast];\n  }\n  pushBack(element: T) {\n    if (this._length) {\n      if (this._curLast < this._bucketSize - 1) {\n        this._curLast += 1;\n      } else if (this._last < this._bucketNum - 1) {\n        this._last += 1;\n        this._curLast = 0;\n      } else {\n        this._last = 0;\n        this._curLast = 0;\n      }\n      if (\n        this._last === this._first &&\n        this._curLast === this._curFirst\n      ) this._reAllocate();\n    }\n    this._length += 1;\n    this._map[this._last][this._curLast] = element;\n    return this._length;\n  }\n  popBack() {\n    if (this._length === 0) return;\n    const value = this._map[this._last][this._curLast];\n    if (this._length !== 1) {\n      if (this._curLast > 0) {\n        this._curLast -= 1;\n      } else if (this._last > 0) {\n        this._last -= 1;\n        this._curLast = this._bucketSize - 1;\n      } else {\n        this._last = this._bucketNum - 1;\n        this._curLast = this._bucketSize - 1;\n      }\n    }\n    this._length -= 1;\n    return value;\n  }\n  /**\n   * @description Push the element to the front.\n   * @param element - The element you want to push.\n   * @returns The size of queue after pushing.\n   */\n  pushFront(element: T) {\n    if (this._length) {\n      if (this._curFirst > 0) {\n        this._curFirst -= 1;\n      } else if (this._first > 0) {\n        this._first -= 1;\n        this._curFirst = this._bucketSize - 1;\n      } else {\n        this._first = this._bucketNum - 1;\n        this._curFirst = this._bucketSize - 1;\n      }\n      if (\n        this._first === this._last &&\n        this._curFirst === this._curLast\n      ) this._reAllocate();\n    }\n    this._length += 1;\n    this._map[this._first][this._curFirst] = element;\n    return this._length;\n  }\n  /**\n   * @description Remove the _first element.\n   * @returns The element you popped.\n   */\n  popFront() {\n    if (this._length === 0) return;\n    const value = this._map[this._first][this._curFirst];\n    if (this._length !== 1) {\n      if (this._curFirst < this._bucketSize - 1) {\n        this._curFirst += 1;\n      } else if (this._first < this._bucketNum - 1) {\n        this._first += 1;\n        this._curFirst = 0;\n      } else {\n        this._first = 0;\n        this._curFirst = 0;\n      }\n    }\n    this._length -= 1;\n    return value;\n  }\n  getElementByPos(pos: number): T {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    const {\n      curNodeBucketIndex,\n      curNodePointerIndex\n    } = this._getElementIndex(pos);\n    return this._map[curNodeBucketIndex][curNodePointerIndex]!;\n  }\n  setElementByPos(pos: number, element: T) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    const {\n      curNodeBucketIndex,\n      curNodePointerIndex\n    } = this._getElementIndex(pos);\n    this._map[curNodeBucketIndex][curNodePointerIndex] = element;\n  }\n  insert(pos: number, element: T, num = 1) {\n    const length = this._length;\n    $checkWithinAccessParams!(pos, 0, length);\n    if (pos === 0) {\n      while (num--) this.pushFront(element);\n    } else if (pos === this._length) {\n      while (num--) this.pushBack(element);\n    } else {\n      const arr: T[] = [];\n      for (let i = pos; i < this._length; ++i) {\n        arr.push(this.getElementByPos(i));\n      }\n      this.cut(pos - 1);\n      for (let i = 0; i < num; ++i) this.pushBack(element);\n      for (let i = 0; i < arr.length; ++i) this.pushBack(arr[i]);\n    }\n    return this._length;\n  }\n  /**\n   * @description Remove all elements after the specified position (excluding the specified position).\n   * @param pos - The previous position of the first removed element.\n   * @returns The size of the container after cutting.\n   * @example\n   * deque.cut(1); // Then deque's size will be 2. deque -> [0, 1]\n   */\n  cut(pos: number) {\n    if (pos < 0) {\n      this.clear();\n      return 0;\n    }\n    const {\n      curNodeBucketIndex,\n      curNodePointerIndex\n    } = this._getElementIndex(pos);\n    this._last = curNodeBucketIndex;\n    this._curLast = curNodePointerIndex;\n    this._length = pos + 1;\n    return this._length;\n  }\n  eraseElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    if (pos === 0) this.popFront();\n    else if (pos === this._length - 1) this.popBack();\n    else {\n      const length = this._length - 1;\n      let {\n        curNodeBucketIndex: curBucket,\n        curNodePointerIndex: curPointer\n      } = this._getElementIndex(pos);\n      for (let i = pos; i < length; ++i) {\n        const {\n          curNodeBucketIndex: nextBucket,\n          curNodePointerIndex: nextPointer\n        } = this._getElementIndex(pos + 1);\n        this._map[curBucket][curPointer] = this._map[nextBucket][nextPointer];\n        curBucket = nextBucket;\n        curPointer = nextPointer;\n      }\n      this.popBack();\n    }\n    return this._length;\n  }\n  eraseElementByValue(value: T) {\n    const length = this._length;\n    if (length === 0) return 0;\n    let i = 0;\n    let index = 0;\n    while (i < length) {\n      const element = this.getElementByPos(i);\n      if (element !== value) {\n        this.setElementByPos(index, element!);\n        index += 1;\n      }\n      i += 1;\n    }\n    this.cut(index - 1);\n    return this._length;\n  }\n  eraseElementByIterator(iter: DequeIterator<T>) {\n    const _node = iter._node;\n    this.eraseElementByPos(_node);\n    iter = iter.next();\n    return iter;\n  }\n  find(element: T) {\n    for (let i = 0; i < this._length; ++i) {\n      if (this.getElementByPos(i) === element) {\n        return new DequeIterator<T>(i, this);\n      }\n    }\n    return this.end();\n  }\n  reverse() {\n    this._map.reverse().forEach(function (bucket) {\n      bucket.reverse();\n    });\n    const { _first, _last, _curFirst, _curLast } = this;\n    this._first = this._bucketNum - _last - 1;\n    this._last = this._bucketNum - _first - 1;\n    this._curFirst = this._bucketSize - _curLast - 1;\n    this._curLast = this._bucketSize - _curFirst - 1;\n    return this;\n  }\n  unique() {\n    if (this._length <= 1) {\n      return this._length;\n    }\n    let index = 1;\n    let pre = this.getElementByPos(0);\n    for (let i = 1; i < this._length; ++i) {\n      const cur = this.getElementByPos(i);\n      if (cur !== pre) {\n        pre = cur;\n        this.setElementByPos(index++, cur);\n      }\n    }\n    this.cut(index - 1);\n    return this._length;\n  }\n  sort(cmp?: (x: T, y: T) => number) {\n    const arr: T[] = [];\n    for (let i = 0; i < this._length; ++i) {\n      arr.push(this.getElementByPos(i));\n    }\n    arr.sort(cmp);\n    for (let i = 0; i < this._length; ++i) {\n      this.setElementByPos(i, arr[i]);\n    }\n    return this;\n  }\n  /**\n   * @description Remove as much useless space as possible.\n   */\n  shrinkToFit() {\n    if (this._length === 0) return;\n    const newMap = [];\n    if (this._first === this._last) return;\n    else if (this._first < this._last) {\n      for (let i = this._first; i <= this._last; ++i) {\n        newMap.push(this._map[i]);\n      }\n    } else {\n      for (let i = this._first; i < this._bucketNum; ++i) {\n        newMap.push(this._map[i]);\n      }\n      for (let i = 0; i <= this._last; ++i) {\n        newMap.push(this._map[i]);\n      }\n    }\n    this._first = 0;\n    this._last = newMap.length - 1;\n    this._map = newMap;\n  }\n  forEach(callback: (element: T, index: number, deque: Deque<T>) => void) {\n    for (let i = 0; i < this._length; ++i) {\n      callback(this.getElementByPos(i), i, this);\n    }\n  }\n  * [Symbol.iterator]() {\n    for (let i = 0; i < this._length; ++i) {\n      yield this.getElementByPos(i);\n    }\n  }\n}\n\nexport default Deque;\n"]}